
<!-- 
konfiguracje gracza:

nothing:0/1
killradius:num/ can be null
killsprites:[ sprite 1...inf ]object/can be null
code:{};
speed:1
gravity:def
oncollision:[[tile,code line,scripname], ... ] ]object
buttonsgui=[
"up":moveUP(),
"kill": remove_nearest_sprite(sprite)
]

sprite configuration:
code:{}
oncollision:[[tile,code line,scriptname], ... ] ]object
entity: boolean1/0,
npcrandommove: boolean1/0,
npcconfig:[]
blockwithcollisions: boolean1/0,
havecollisionswithblocks:[],








nowe komendy
copy(sprite) 
 kopiuje bierzacą pozycje kafelka danego nie można określić wszystkich 
 robiąc coś takiego piszesz sprite1-0 
 0 to orginał...  do nieskończoność
 -1 to ostatni klon
paste(sprite)





start: - funkcja startowa
spzhz(hz) - funkcja na innych Hertzach
root : kod systemowy biblioteki JS itp

example code
start:
1:
2:
3: !scriptname!
scriptname:
1: 
2:
3:
root:
1:let state=0
2:if state==0 
3:state=1
4: ; else
5:state=0
6: ;
7: root!

-->



<script>
  var shader={
    "DarknessEffect":1,
    "Sepia":0,
    "Noises":0,
  }
  
  
  setTimeout(function(){
    if (!(config.guiHTML2)) {
      config.guiHTML2 = ""
    }
if(config.DarknessEffect==1){
  let vp =document.getElementById("viewport")
  let el= document.createElement('div')
  el.style=`width:${vp.style.width};height:${vp.style.height};`
  el.className='dark effects added'
  document.querySelector('#project').appendChild(el)
}else{
let y = document.querySelectorAll('.effects')
for (var i = 0; i < y.length; i++) {
 if(y[i].classList=='dark'){
  y[i].remove()
 }
}
}
  },1000)
</script>
<style>
  .dark{
    background: radial-gradient(#FF000000,#000000 45%);
    top:50vh;
    position: fixed;
    left:50vw;
    transform: translate(-50%,-50%);
    z-index: 0;
  }
</style>
<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta http-equiv="X-UA-Compatible" content="IE=7">

<audio id="audio2"src="/chrome.wav"></audio>
<p id="mbs" style="position: absolute;z-index: 999; color:lime; display: none"></p>
<!-- Paste There Your Watermark ; ) -->
<!-- author: none -->

 <img src="./watermark.gif" onclick="config.testmode = config.testmode === 1 ? 0 : 1;up1()"style="position: fixed; top:0; left:10px; image-rendering: pixelated; width:100px;height:30px; transform: translate(0,25%); z-index: 99999999999" >
 <style>
 :root{
   position:fixed;
  width: 100vw;
  height:100vh;
 }
 </style>
<script>let isgamepaused = 0;

let mbs=document.querySelector("#mbs")
window.addEventListener('load', function () {
    var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    var speed = connection.downlink; // Prędkość pobierania w megabitach na sekundę
mbs.innerHTML = speed+'mb/s'
    if (speed && speed < 2) { // Przykładowa wartość, dostosuj według potrzeb
        mbs.innerHTML = '<h1>.</h1>';
    }
});
</script>
<script>
  function togglemode1(){
    var elementsToHide = document.getElementsByClassName('d');
    Array.from(elementsToHide).forEach(element => {
      element.classList.toggle('hide')
    });
  }
  setTimeout(function(){
    var elementsToHide = document.getElementsByClassName('d');
    Array.from(elementsToHide).forEach(element => {
      element.classList.toggle('hide')
    });
  },1000)
  var leftButtonDown = 0;
var rightButtonDown = 0;
var upButtonDown = 0;
var downButtonDown = 0;

</script>
<script src="./defaul.js"></script>
<script>
  var sizescale=config.tilesize;
</script>
  <style>
.b{
  
}

    #blackScreen {
      
      
      display: none;
      position: absolute;
      z-index:999999999;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: black;
    //  display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 1;
      transition: opacity 2s ease-in-out;
    }
.hide3{
  display: none;
  visibility: hidden;
  touch-action: none;
}
    #helloWorldText {
      display: block;
      position: absolute;
      top:50vh;
      left:50vw;
      transform: translate(-50%,-50%);
      opacity: 1;
      transition: opacity 1s ease-in-out;
    }
  </style>
  </head>

  <body>
    <div id="blackScreen">
      <pre id="helloWorldText" style="white-space: pre-wrap"></pre>
    </div>

    <script>
      const helloWorldText = document.getElementById('helloWorldText');
      const textsArray = [
`
 Welcome In <img src="./logo.gif" style="width:100px;height:30px; transform: translate(0,25%)" >
  `,
`
  <img src="./logo.gif" style="width:100px;height:30px; transform: translate(0,25%)" > is free open source program 
  
Consout all rights reserved ©
`,

`
---------------------------
v0.1beta | 2023 6.02 update
`];
      let currentIndex = 0;

      setTimeout(() => {
        const blackScreen = document.getElementById('blackScreen');
        fadeInNextText();

        function fadeInNextText() {
          helloWorldText.style.opacity = 0;

          setTimeout(() => {
            if (currentIndex < textsArray.length) {
              helloWorldText.innerHTML = textsArray[currentIndex];
              helloWorldText.style.opacity = 1;

              setTimeout(() => {
                fadeInNextText();
              }, 3500);

              currentIndex++;
            } else {
              blackScreen.style.opacity = 0;

              setTimeout(() => {
                blackScreen.style.display = 'none';
              }, 2000);
            }
          }, 1000);
        }
      }, 2000);
    </script>





<script>
/*
CONFIG VABLES
*/
/*var config={

],
"savedTileMap":null,
"playerskin1":"/0 (6).png",
}
*/


var tileMap =
[[[9, 10, 1]],[],[]]

let update3=()=>{ document.querySelector('#player').style.background=`url("${config.playerskin1}");`;config.playerskin1=playerskin;config.bg=bgimg;config.blocks=TILES;config.savedTileMap=tileMap;config.px=(playerX)/tileSize;config.py=playerY/tileSize; console.log(config) }
//playerskin=config.playerskin1
setTimeout(function(){
 // alert(config.bg)
  // Pobierz element o id "content"
  playerskin=config.playerskin1
//alert(config.playerskin1)
var contentElement = document.getElementById("content");
contentElement.style.backgroundImage = `url('${config.bg}')`;
TILES=config.blocks
tileMap=config.savedTileMap
checki1()
var playerelement = document.getElementById("player");
playerelement.style.backgroundImage = `url('${config.playerskin1}')`;

  
  //playerskin = newImage
  updateViewport();
//  alert(JSON.stringify(document.querySelector('#content').style.background))
  window.setInterval(update3,5000)
},100)
setTimeout(function (){
  document.querySelector('.player').style.background = `url(${config.playerskin1});`;
  
  
  playerskin = config.playerskin1
},1600)
function dld2(){
//const newImage = URL.createObjectURL(config.playerskin1); // Use the selected file as the image
  
  
}
window.setInterval(dld2,20)
setTimeout(function(){
document.getElementById('project').style.zoom="1.0"
//document.getElementById('viewport').style.zoom="1.3"
},500)





</script>



  <button class="notaproject d" style="position: absolute; left:30vw; bottom:0px; background: blue; z-index: 99999" onclick="saveToFile()">Zapisz do pliku</button>


<button class="notaproject d" style="position: absolute; left:0vw; bottom:0px; background: blue; z-index: 99999" onclick="chooseFile()">Wybierz plik WAV</button>

<script>
let toonce = 1;
let audioInstance = null;

function handleClick() {
    if (toonce === 1) {
        if (audioInstance) {
            // Jeżeli istnieje istniejący odtwarzacz audio, zatrzymaj go
            audioInstance.pause();
            audioInstance.currentTime = 0;
            audioInstance = null;
        }

        if (config.music !== '') {
            const base64Wav = config.music;

            // Utwórz nowy odtwarzacz audio
            audioInstance = new Audio();
            audioInstance.src = base64Wav;
            audioInstance.setAttribute('preload', 'auto');

            // Dodaj odtwarzacz do dokumentu
            document.body.appendChild(audioInstance);

            // Odtwórz plik audio WAV
            audioInstance.play();
            audioInstance.loop = true;
            toonce = 0;
        }
    }
}

// Dodaj nasłuchiwanie na kliknięcie
document.addEventListener('click', handleClick);

function chooseFile() {
    // Utwórz element input typu file
    const input = document.createElement('input');
    input.type = 'file';

    // Dodaj obsługę zdarzenia po wybraniu pliku
    input.addEventListener('change', function() {
        const file = input.files[0];
        toonce = 1;

        if (file) {
            // Odczytaj zawartość pliku jako base64
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64Wav = e.target.result;

                // Jeżeli istnieje istniejący odtwarzacz audio, zatrzymaj go
                if (audioInstance) {
                    audioInstance.pause();
                    audioInstance.currentTime = 0;
                    audioInstance = null;
                }

                // Przypisz base64Wav do config.music lub wykonaj inną operację
                config.music = base64Wav;

                // Utwórz nowy odtwarzacz audio
                audioInstance = new Audio();
                audioInstance.src = base64Wav;
                audioInstance.setAttribute('preload', 'auto');

                // Dodaj odtwarzacz do dokumentu
                document.body.appendChild(audioInstance);

                // Możesz dodać dodatkową logikę związana z odtwarzaniem pliku audio
            };
            reader.readAsDataURL(file);
        }
    });

    // Wywołaj kliknięcie na element input
    input.click();
}

</script>



<div>
  
</div>
<script>
 // toggle(b)
</script>
  <script>
    function saveToFile() {
config.blocks.push([TILES.length,1,"/ NAN.png"])
config.code = code;
config.debugmode=0
config.testmode=0
let code2=JSON.stringify(config)
      // Tworzymy obiekt Blob, który reprezentuje dane do zapisania
      let blob = new Blob([code2], { type: "text/plain" });

      // Tworzymy element <a> do generowania pliku
      let a = document.createElement("a");

      // Przypisujemy do atrybutu "href" obiekt Blob
      a.href = window.URL.createObjectURL(blob);

      // Nadajemy plikowi nazwę
      a.download = "defaul.js";

      // Symulujemy kliknięcie przycisku do pobrania pliku
      a.click();
      
    }
  </script>






<html lang="en" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Total Adjustable Game by kP</title>
  <style>
    body {
      margin: 0;
      background: #000000;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    #container {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 70%;
      height: 70%;
      border: 1px solid #ccc;
      overflow: hidden;
    }

    #toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #f1f1f1;
      padding: 10px;
      overflow-x: scroll;
    }

    .tool {
      display: inline-block;
      margin-right: 20px;
    }

    .menu-btn, .options-btn {
      cursor: pointer;
      margin-right: 10px;
    }

    .selected {
      background-color: lightblue;
    }

    .hidden {
      display: none;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
    }

    .popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      padding: 20px;
      z-index: 2;
    }

    #sidebar {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      width: 10%;
      background-color: #ddd;
      overflow-y: scroll;
      padding: 10px;
    }

    .tab {
      margin-bottom: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }

    .tab:hover {
      background-color: #eee;
    }

    .tab img {
      margin-right: 5px;
    }

    .content {
      margin-left: 10%;
    }
        .Econtent {
          touch-action: none;
          position: absolute;
          margin-left: 10%;
        }
                .Scontent {
                  touch-action: none;
                  position: absolute;
                  margin-left: 10%;
                }
#info{
  position: fixed;
  right:0;
  top:calc(80% - 20px);
}
    .nested-div {
      margin-left: 20px;
      cursor: pointer;
    }
    .dr{
      width:50px;
      height:50px;
    }
  </style>
</head>
<body>
<!-- <div onclick="cofnijczas(2)" style="position: absolute; 
top:20px; right:20px; width: 30px ; height:30px ; background: red;"> -->

  
</div>

<div id="project">


  <div id="viewport">
  <div id="player" class="player">
  </div>
  <div id="content"></div>
    <div id="Econtent"></div>
    <div id="Scontent"></div>
</div>
  <div id="project2">

  </div>
<script>
  document.querySelector('#viewport').style.width = config.width + "px"
  document.querySelector('#viewport').style.height = config.height + "px"
</script>
	<div class="joystick">	  <div class="stick"></div>
  </div>
 	  <div class="jumpbtn added" id="Jump" ></div>
 	   	  <div class="jumpbtn added" id="Attack" style="transform: translate(0%,-100%)" onclick="attack2()"></div>

</div>
<style>
  #project{
    position: absolute;
    background: #000000;
    width: 100%;
    height: 100vh;
  }
  #project2 {
    position: absolute;
    background: #00000000;
        pointer-events: none ;
    width: 100%;
    height: 100vh;
  }
</style>
<html onclick="setTimeout(function(){document.documentElement.requestFullscreen()},200)">
  <audio id="audio" src="./stray_22 - Rikonium.mp3"></audio>
<!-- 
     wirtualizowanie
     virtualization 
     to naj lepszy sposób aby gra działa 
     płynnie
-->
<!--
silnik top down do dopracowania
Silnik Kolizji , Wirtualizacja , Kafelki
Unlicense 
reszta
Licence MiT 
-->
<title></title>

<div class="f notaproject" style="position: fixed; width: 110px; height: calc(100vh - 60px) ; background: grey; z-index: 0;overflow: hidden;right:0;
white-space: pre-wrap; overflow : scroll;">
</div>
<div style="position: fixed; width: 110px; height: 50px; background: yellow; z-index:0;overflow: hidden;right:0;bottom:0px;
white-space: pre-wrap; overflow : scroll; " onclick="togglemode1()" class="notaproject"></div>
<style>
.f{
  
}
  .f div{
    margin-right:5px;
  }
</style>
<script>
setTimeout(function(){
  
},500)
var first1=0
function checki1(){
  if (first1 == 0) {
    
    // alert(last)
    first1 = 1
  }
setTimeout(function (){
  let v=[]
for (let i=0;i<TILES.length;i++){
  
let cnt=document.querySelector('.f')

if(TILES[i][2]){
  if(TILES[i][2]!=='/ NAN.png'){
//  alert(TILES[i][2])
 v +=`<div style="width: 30px;
 height: 30px;
 display: inline-block;
 image-rendering: pixelated;
 background:url('${TILES[i][2]}');
 background-size:100%; color:black; font-size:6px;
 " ondblclick="changeTexture(${TILES[i][0]})" onclick="build(${TILES[i][0]})">i${TILES[i][0]} , S${TILES[i][1]}
</div>`

cnt.innerHTML=v
}
}}
},0)
}
window.setInterval(checki1,2000)
function build(e){
  item=e
}

let selectedTileIndex = null;



function changeTexture(index) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    
    fileInput.addEventListener('change', (event) => {
        const files = event.target.files;

        if (files.length > 0) {
            const newBlockIndex = TILES.length; // Get the next iteration
            const collisionValue = 1;
            const image = event.target.files[0];

            // Create file reader object
            const reader = new FileReader()

            // Convert image to data URL
            reader.readAsDataURL(image)

            reader.addEventListener('load', () => {
                // Zmiana tekstury dla wybranego indeksu
                TILES[index][2] = reader.result;
                updateViewport();
            })
        }
    });

    // Automatyczne otwarcie okna dialogowego do wyboru pliku po kliknięciu przycisku
    fileInput.click();
}

</script>


<style>
  #container123212{
    position: absolute; top:100px;left:10px;zoom:0.7
  }
  #container12321{
    position: absolute; top:200px;left:10px;zoom:0.7
  }
  #container123211{
    position: absolute; top:300px;left:10px;zoom:0.7
  }
  
</style>
<div id="container123212" class="notaproject  a hide2">
  <div  class="box0" onclick="add123212()"   >+</div>
  <div id="value123212" class="box1"                      >entity alltiles</div>
  <div class="box0" onclick="sub123212()"   >-</div>
</div>
<script>
var isentity=2;
  function add123212(){ if(isentity > -1 ){ isentity +=1; updt212()}}function sub123212(){if(isentity > 0 ){ isentity -=1 ; updt212()}}function updt212(){document.getElementById('value123212').innerText=isentity; updateViewport()}
</script>
<div id="container12321" class="notaproject  a hide2">
  <div  class="box0" onclick="add12321()"   >+</div>
  <div id="value12321" class="box1"                      >scale 1</div>
  <div class="box0" onclick="sub12321()"   >-</div>
</div>
<script>
var thistilesize=1;
  function add12321(){ if(thistilesize > -1 ){ thistilesize +=0.5; updt21()}}function sub12321(){if(thistilesize > 0 ){ thistilesize -=0.5 ; updt21()}}function updt21(){document.getElementById('value12321').innerText=thistilesize; updateViewport()}
</script>
<div id="container123211" class="notaproject  a hide2">
  <div  class="box0" onclick="add123211()"   >+</div>
  <div id="value123211" class="box1"                      >TY 0</div>
  <div class="box0" onclick="sub123211()"   >-</div>
</div>
<script>
var translateY=0;
  function add123211(){ if(true ){ translateY +=0.5; updt211()}}function sub123211(){if(true){ translateY -=0.5 ; updt211()}}function updt211(){document.getElementById('value123211').innerText=translateY; updateViewport()}
</script>

  <input type="file" class="a hide2" style="position: absolute ;top:calc(5% + 30px);left:20%;" accept="image/png/gif" id="imageInput" style="display: none;">
  <button class="a hide2" style="position: absolute ;top:calc(5% + 30px);left:20%;" id="addButton">Dodaj cb <br></button>
  
  
  
    <input type="file" class="a hide2" style="position: absolute; top:calc(5% + 60px);left:20%; width: 30px" accept="image/png/gif" id="imageInput2" style="display: none;">
  <button class="a hide2" style="position: fixed; top:calc(5% + 60px);left:20%;"id="addButton2">Dodaj no cb <br></button>
  
        <input type="file" class="a hide2" style="position: absolute; top:calc(5%);left:20%;width: 30px" accept="image/png/gif" id="imageInput5" style="display: none;">
        <button class="a hide2" style="position: fixed; top:calc(5%);left:20%;" id="addButton5">dodaj eb noc<br></button>
      <input type="file" class="a hide2" style="position: absolute; top:calc(5% + 90px);left:20%;width: 30px" accept="image/png" id="imageInput3" style="display: none;">
      <button class="a hide2" style="position: fixed; top:calc(5% + 90px);left:20%;" id="addButton3">zmień gracza<br></button>
  
  
      <input class="a hide2" type="file" style="position: absolute; top:calc(5% + 120px);left:20%;width: 30px" accept="image/png" id="imageInput4" style="display: none;">
      <button class="a hide2" style="position: fixed; top:calc(5% + 120px);left:20%;" id="addButton4">zmień tlo<br></button>
      
	  <p id="cns" ><p id="fps"></p>
	  <p id="console" class="notaproject"></p></p>
<style>
#cns{
  position :absolute ;
  top :0;
  left :200px;
  z-index :5;
}
.darkness{
  position :absolute ;
  width: 100vw;
  background-image : radial-gradient(circle,#00000026 20%,#000000C9 40%);
  height: 100vh;
  z-index :1;
 left: 0;
}
#woter {
  position: absolute;
  width: 150vw;
  background-image: radial-gradient(circle, #00000026 20%, #000000D1 50%);
  height: 100vh;
  z-index: 1;
  animation :2s d infinite;
}
@keyframes d{
  0%{
    rotate: 20deg;
    opacity :0.1;
  }
  100%{
    rotate: 30deg ;
    opacity :0.01;
  }
}
#console {
width: 100%;
color:white;
background: #00000047;
position: absolute;
z-index: 999;
bottom: 0
}
.player {
  position: absolute;
  z-index: 6;
  width: 14px;
  background: #2D2D2D;
  height: 14px;
  display: flex;
  justify-content: center;
  text-align: center;
  align-items: center;
  background: url('/0 (3).png');
  background-size: 100%;
  image-rendering: pixelated;
}

.player::after {
  content: ''; /* Dodaj pusty content do pseudo-elementu ::after */
  position: absolute;
  z-index: 6; /* Ustaw niższy indeks z-index niż .player, aby był poniżej */
  width: 150%; /* Ustaw szerokość na 100% elementu .player */
  height: 150%; /* Ustaw wysokość na 100% elementu .player */
  background: inherit;
  background-size: 100%; /* Możesz dostosować wielkość pseudo-elementu */
  transform: scale(1.2); /* Ustaw skalę pseudo-elementu */
}

#fps{
  position: fixed;
  display: none;
  top:0;
  left:0;
}
		.joystick {
		  display: none;
  position: fixed ;
  z-index :2;
  bottom :60px;
  right:70%;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: #978A8A42;
}
.jumpbtn{
position: fixed;

  z-index :2;
  bottom :60px;
  right:150px;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: #6F6F6FA1;
}
.stick {
  position: absolute;
  width: 50px;
  height: 50px;
  top: 25px;
  left: 25px;
  border-radius: 50%;
  background-color: #00000080;
}
#viewport {
  
  overflow: auto;
 transform: translate(-50%, -50%);
  top:50%;
  left:50%;
  position :absolute ;
  
}
#content {
  position: relative;
  
  image-rendering: pixelated;
  
}
.tile {
  position: absolute;
  
  
  
  image-rendering: pixelated;
  background-size: 32px;
  box-sizing: border-box;
}
.tile1 {
  position: absolute;
  
  
  
  image-rendering: pixelated;
  background-size: 32px;
  box-sizing: border-box;
}

.sampletile {
  position: absolute;
  width: 32px;
  height: 32px;
  background-color: #00000000;
  image-rendering: pixelated;
  background-size: 32px;
  box-sizing: border-box;

}
.alltiles{
  
}
.line-number{
  background: #42445A70;
  color:#FFFFFF;
  width: 32px;
  font-size: 6px;
  height:32px;
  z-index: 2;
  position: absolute;
}
.SPRITE{
  background-size: cover; /* Dopasowuje obraz do wymiarów bloku, zachowując proporcje */
  background-position: center center; /* Ustawia pozycję obrazu w centrum bloku */
width: 10%;
height: 10%
}
</style>
<script>
const viewport = document.getElementById('viewport');
const content = document.getElementById('content');
var showlines=0
content.style.backgroundSize=(config.bgsize)+"px"
//alert(content.style.backgroundSize)
var tileSize = config.tilesize; // Rozmiar pojedynczego kafelka

var cfigZ = config.zoomoff;
var vp = document.getElementById("viewport");

vp.style.zoom = cfigZ*config.zoomadd;

var originalWidth = parseInt(vp.style.width);
var originalHeight = parseInt(vp.style.height);

var newWidth = originalWidth /cfigZ;
var newHeight = originalHeight / cfigZ;

vp.style.width = newWidth + "px";
vp.style.height = newHeight + "px";
if(config.testmode==0){
  newWidth = config.width;
newHeight = config.height;
cfigZ=1; 
vp.style.zoom = cfigZ;
 newWidth = config.width;
 newHeight = config.height;
vp.style.width = newWidth + 'px';
vp.style.height = newHeight + 'px';
}
const viewportWidth = viewport.clientWidth;
const viewportHeight = viewport.clientHeight;
const numTilesX = 99999// Liczba kafelków w osi X
const numTilesY = 99999; // Liczba kafelków w osi Y
const contentWidth = numTilesX ;
const contentHeight = numTilesY;
content.style.width = contentWidth + 'px';
content.style.height = contentHeight + 'px';
let numVisibleTilesX = Math.ceil(viewportWidth/tileSize);
let numVisibleTilesY = Math.ceil(viewportHeight/tileSize );
let startTileX = 0; // Indeks początkowego kafelka w osi X
let startTileY = -2; // Indeks początkowego kafelka w osi Y
const tileCache = {}; // Obiekt przechowujący kafelki w pamięci podręcznej
let lastplayerpos = [];
var dimension = 0;

var canJUMP=0

/*
-------------
HELP FULL DATA
--------------
*/
var TILES = config.blocks;
var blockstoaddtocollision=[
]
var deletedtiles=[]
// Funkcja do obsługi obserwatora
function handleIntersection(entries) {
  entries.forEach((entry) => {
    const tile = entry.target;

    if (!entry.isIntersecting && tile.parentElement.id === 'Econtent') {
return 1;
    }
  });
}

function calculateVisibleTiles() {
  const numVisibleTilesX = Math.ceil(viewportWidth / sizescale)+1;
  const numVisibleTilesY = Math.ceil(viewportHeight / sizescale)+1;
  return { numVisibleTilesX, numVisibleTilesY };
}
// Utwórz obserwator
const observer = new IntersectionObserver(handleIntersection, { threshold: 0.5 });

// Znajdź i zarejestruj elementy w #Econtent
function up1() {
  setTimeout(function() {
    newWidth = config.width;
      newHeight = config.height;
      cfigZ = 0;
      vp.style.zoom = cfigZ;
      newWidth = config.width;
      newHeight = config.height;
      vp.style.width = newWidth + 'px';
      vp.style.height = newHeight + 'px';
      
    if (config.testmode == 1) {
      
      cfigZ = config.zoomadd
      vp.style.zoom = cfigZ * config.zoomadd;
      
      originalWidth = parseInt(vp.style.width);
      originalHeight = parseInt(vp.style.height);
      
      newWidth = originalWidth / cfigZ;
      newHeight = originalHeight / cfigZ;
      
      vp.style.width = newWidth + "px";
      vp.style.height = newHeight + "px";
    }
    if (config.testmode === 1) {
      document.getElementById('viewport').style.left = "50%"
      var elementsToHide = document.getElementsByClassName('notaproject');
      Array.from(elementsToHide).forEach(element => {
        element.classList.add('hide3')
      });
      var elementsTomove = document.getElementsByClassName('jumpbtn');
      Array.from(elementsTomove).forEach(element => {
        element.style.right = '1px';
      });
    } else {
      document.getElementById('viewport').style.left = "50%"
      var elementsToHide = document.getElementsByClassName('notaproject');
      Array.from(elementsToHide).forEach(element => {
        element.classList.remove('hide3')
      });
      var elementsTomove = document.getElementsByClassName('jumpbtn');
      Array.from(elementsTomove).forEach(element => {
        element.style.right = '1px';
      });
    }
  }, 30)
}
setTimeout(up1,1000)
function updateViewport() {
  content.innerHTML=""
  const scrollLeft = viewport.scrollLeft;
  const scrollTop = viewport.scrollTop;
  const { numVisibleTilesX, numVisibleTilesY } = calculateVisibleTiles();

  const startTileX = Math.floor(scrollLeft / tileSize);
  const startTileY = Math.floor(scrollTop / tileSize);
  const endTileX = startTileX + numVisibleTilesX;
  const endTileY = startTileY + numVisibleTilesY;

const fragment = document.createDocumentFragment();


    var treh = 0;
    var s = 0;

    for (let x = startTileX; x < endTileX; x++) {
      for (let y = startTileY; y < endTileY; y++) {
        let cty = 0;
        const tileKey = `${x}-${y}`;

        if (true) {
          const tileCoords = [x * 1, y * 1];
          
          const tileType = tileMap[dimension].find(
            (coords) => coords[0] === tileCoords[0] && coords[1] === tileCoords[1]
          );
const tileCoords2 = [x, y];
      const matchingTiles = tileMap[dimension].filter(
        (coords) => coords[0] === tileCoords2[0] && coords[1] === tileCoords2[1]
      );
let blockzindex=0
      matchingTiles.forEach((tileType) => {
       blockzindex++
       const tile = document.createElement('div');
          if (tileType) {
            if (tileType[2] === 1) {
              tile.className = 'tile alltiles';
              treh = 0;
              s = 0;
            } else {
              tile.className = `tile${parseFloat(tileType[2])} alltiles`;

              for (let i = 0; i < TILES.length; i++) {
             //   console.log(TILES.length)
                if (TILES[i][0] == tileType[2]) {
                  if (TILES[i][1] == 1) {
                    tile.className = `tile alltiles`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                  }else  if (TILES[i][1] == 4) {
                    tile.className = `tile1  alltiles hurtblock`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                  } else if (TILES[i][1] == 2) {
                    tile.className = `tile alltiles2`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                    const existingTile = document.querySelector(`.alltiles2[data-x="${x}"][data-y="${y}"][data-s="${s}"]`);
const similarDeletedTile = deletedtiles.find((deletedTile) => {
  return deletedTile.dataset.x === x.toString() && deletedTile.dataset.y === y.toString() && deletedTile.dataset.s === s.toString();
});
                    if (!existingTile && !similarDeletedTile) {
                      tile.dataset.x = x;
                      tile.dataset.y = y;
                      tile.dataset.s = s;
                      tile.style.left = x * tileSize + 'px';
                      tile.style.top = (y + treh) * tileSize + 'px';
                      document.querySelector('#Econtent').appendChild(tile);
                    }
                    cty = 1;
                  }else if (TILES[i][1] > 2) {
                    // customowe alltiles
                    tile.className = `tile alltiles${TILES[i][1]} entities`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                    const existingTile = document.querySelector(`.alltiles${TILES[i][1]}[data-x="${x}"][data-y="${y}"][data-s="${s}"]`);
const similarDeletedTile = deletedtiles.find((deletedTile) => {
  return deletedTile.dataset.x === x.toString() && deletedTile.dataset.y === y.toString() && deletedTile.dataset.s === s.toString();
});
                    if (!existingTile && !similarDeletedTile) {
                      tile.dataset.x = x;
                      tile.dataset.y = y;
                      tile.dataset.s = s;
                      tile.style.left = x * tileSize + 'px';
                      tile.style.top = (y + treh) * tileSize + 'px';
                      document.querySelector('#Econtent').appendChild(tile);
                    }
                    cty = 1;
                  } else {
                    tile.className = `tile1 alltiles`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                  }
                  tile.classList.add('sprites'+TILES[i+1][0])
                  tile.style.transform=`scale(${TILES[i][3]||1})`;
                 // tile.style.transform='translateY('+(TILES[i][4]||0)*tileSize+"px)";
                }
              }

              treh = 0;
            }
          }
          tile.classList.add('SPRITE')
          // tile.style.willChange = 'transform';
          
          tile.style.width=tileSize-parseInt(tile.style.width/2)+"px"
          tile.style.height=tileSize-parseInt(tile.style.height/2)+"px"
          if (cty == 0) {
            tile.dataset.x = x;
            tile.dataset.y = y;
            tile.dataset.s = s;
            
            if(showlines==1){
            var line=document.createElement('div')
            line.classList='line-number'
            line.style.left = x * tileSize + 'px';
            line.style.top = (y + treh) * tileSize + 'px';
            line.textContent=tile.classList
            fragment.appendChild(line);
            }
            tile.style.left = x * tileSize + 'px';
            tile.style.top = (y + treh) * tileSize + 'px';
            fragment.appendChild(tile);
            
            content.appendChild(fragment);
          }
          if(blockzindex>1){
          tile.style.zIndex=blockzindex+1
          }
        });}
      }
    
  }
}

var elementGenerateAll="10"

function generateAllTiles() {
/*  document.querySelector('#Econtent').innerHTML = "";
  console.log('')
  //const { numTilesX, numTilesY } = calculateTotalTiles();

  const fragment = document.createDocumentFragment();

  tileMap[dimension].forEach((tileCoords) => {
    const matchingTiles = tileMap[dimension].filter(
      (coords) => coords[0] === tileCoords[0] && coords[1] === tileCoords[1]
    );

    matchingTiles.forEach((tileType) => {
      if(tileType[1]==elementGenerateAll){
      const [x, y] = tileCoords;
      const tile = document.createElement('div');
      tile.className = `tile alltiles${tileType[1]} entities`;
      tile.style.backgroundImage = `url("${tileType[2]}")`;
      tile.dataset.x = x;
      tile.dataset.y = y;
      tile.dataset.s = 0; // Assuming s value is always 0 for now
      tile.style.left = x * tileSize + 'px';
      tile.style.top = y * tileSize + 'px';
document.querySelector('#Econtent').appendChild(tile);
     // fragment.appendChild(tile);
    }});
  });

  */
}


generateAllTiles()

// Obsługa zdarzeń przewijania
const scrollInterval = 200; // Czas w milisekundach między sprawdzeniami przewijania
let isScrolling = false;

viewport.addEventListener('scroll', function () {
  isScrolling = true;
});

document.addEventListener("DOMContentLoaded", function() {
  document.addEventListener("click", function(event) {
    if(config.testmode==0){
    if (event.target.classList.contains("entities")) {
      const x = event.target.dataset.x;
      const y = event.target.dataset.y;
      const s = event.target.dataset.s;

      // Remove from the tileMap
      tileMap[dimension] = tileMap[dimension].filter(
        (coords) => coords[0] !== parseFloat(x) || coords[1] !== parseFloat(y) || coords[2] !== parseFloat(s)
      );

      // Remove the element from the DOM
      event.target.remove();
    }}
  });
});


// ... (your existing code)

var entityblocks = [[], [], []];
var killed=0
var score=0
var tileConfig = config.entities
var stop=0

var spritetomove = 0;
function movemap(dataSpriteX, dataSpriteY, tag) {
  dataSpriteX= parseFloat(dataSpriteX)
  dataSpriteY= parseFloat(dataSpriteY)
  tag= parseFloat(tag)
  //alert(tag+""+dataSpriteX+""+dataSpriteY)
  tileMap[dimension].forEach((tileCoords) => {
    const [x, y, t] = tileCoords;

    if (t === tag) {
      let newX = parseInt(x) + parseInt(dataSpriteX);
      let newY = parseInt(y) + parseInt(dataSpriteY);
      
      // Aktualizuj położenie bloku w tablicy tileMap
      tileCoords[0] = newX;
      tileCoords[1] = newY;
tileCoords[0] = newX;
tileCoords[1] = newY;
setTimeout(function(){
  tileCoords[0] = newX;
  tileCoords[1] = newY;
  for (var i = 0; i < 10; i++) {
tileCoords[0] = newX;
    tileCoords[1] = newY;
  }
},5)
      // Usuń bloki z #Econtent o tych samych pozycjach x i y
      let econtentBlocks = document.querySelectorAll("#Econtent div");
      econtentBlocks.forEach((block) => {
        if (parseInt(block.dataset.x) === x && parseInt(block.dataset.y) === y) {
          block.parentNode.removeChild(block);
        }
      });
    }
  });
}



function movesprite(dataSpriteX, dataSpriteY) {
  if (stop == 0) {
    
      if (stop == 0) {
        
        var tiles = document.querySelectorAll(`.${spritetomove}`);
        console.log(spritetomove)
        
        tiles.forEach((tile) => {
          let left = parseFloat(tile.style.left) || 0;
          let top = parseFloat(tile.style.top) || 0;

          top += parseFloat(dataSpriteY);
          left += parseFloat(dataSpriteX);

          tile.style.left = left + "px";
          tile.style.top = top + "px";
        });
      }
    
  }
}function teleportSprite(sourceClass, destinationClass) {
  if (stop == 0) {
    var sourceTiles = document.querySelectorAll(`.${sourceClass}`);
    var destinationTiles = document.querySelectorAll(`.${destinationClass}`);

    sourceTiles.forEach((sourceTile, index) => {
      let destinationTile = destinationTiles[index % destinationTiles.length];

      let left = parseFloat(destinationTile.style.left) || 0;
      let top = parseFloat(destinationTile.style.top) || 0;

      sourceTile.style.left = left + "px";
      sourceTile.style.top = top + "px";
    });
  }
}

function convertspritetoblock(spriteKey) {
  if (stop == 0) {
    let tilesExist = false;

    for (let spriteKey in tileConfig) {
      if (stop == 0) {
        
        var tiles = document.querySelectorAll(`.${spriteKey}`);
        
        if (tiles.length > 0) {
          tilesExist = true;

          tiles.forEach((tile) => {

//alert("yo")
            // Przeniesienie do .content
            
            tile.dataset.hide=true
            
          });
        }
      }
    }

    
  }
}

/*document.querySelectorAll('.entities').forEach((tile) => {
  observer.observe(tile);
});*/
// var load1=0
function moveTilesRandomly() {
  if(stop==0){
    for (let tileId in tileConfig) {
      if(stop==0){
        
        
        
        var [speed, movementType, distance, randomMovement, collision, initialHp, area, deletebool,arena,hurt,vi,score1,collisionobject=".player",detectanabled,collisionwithotherblocks] = tileConfig[tileId];
//console.log(JSON.stringify(tileConfig[tileId]))
        var tiles = document.querySelectorAll(`.${tileId}`);
        
//console.log(JSON.stringify(tileConfig[tileId]))
        tiles.forEach((tile) => {
          const viewport = document.getElementById('viewport');
          const tileRect = tile.getBoundingClientRect();
          const viewportRect = viewport.getBoundingClientRect();
          let left = parseFloat(tile.style.left) || 0;
          let top = parseFloat(tile.style.top) || 0;
          if (!tile.dataset.hp) {
            tile.dataset.hp = initialHp;
          }
                if (collision === 0) {
                    // Change tile class to avoid collision
                    tile.classList.remove('tile');
                    tile.classList.add('tile1');
                }
                let distanceToPlayer = Math.sqrt((playerX - left / tileSize) ** 2 + (playerY - top / tileSize) ** 2);
                if (attack === 1 && distanceToPlayer <= 1) {
                  //alert("")
                  // Player attacks entity, decrement HP
                  tile.dataset.hp -= 1;
                  console.log(tile.dataset.hp);

                  if (tile.dataset.hp < 1) {

                    deletedtiles.push(tile);


                    if (score1 == 1) {
                      score += 1
                    } else {
                      killed += 1;
                    }
                    // Remove 
                    // Entity is defeated, remove the tile
                    tile.remove();
                  }
                }
                if (!(tile.dataset.bugfix1)) {
                  tile.dataset.bugfix1 = 0
                }
tile.dataset.bugfix1++
          if(collisionwithotherblocks==1){
          let power=1


let tiles3 = document.querySelectorAll('.tile5 , .tile');
for (let tile2 of tiles3) {
          const rect1 = tile.getBoundingClientRect();
          const rect2 = tile2.getBoundingClientRect();
          const wallThickness = 2;
          
          if (rect1.bottom > rect2.top + 5 &&
            rect1.top < rect2.bottom - 10 &&
            rect1.right + 5 > rect2.left + 5 &&
            rect1.left < rect2.right - 5) {
          } else {
          }
          if (rect1.top < rect2.bottom + 3 && rect1.bottom > rect2.bottom + 3 && rect1.right > rect2.left && rect1.left < rect2.right) {
          
            top +=power * speed;

            
          }
          if (rect1.left +3< rect2.right + wallThickness && rect1.right > rect2.right && rect1.bottom > rect2.top  && rect1.top < rect2.bottom ) {

            left += power*speed;
          }
          if (
              rect1.right > rect2.left - 3 &&
              rect1.left < rect2.left &&
              rect1.bottom > rect2.top &&
              rect1.top < rect2.bottom
            ) {




            left -= power * speed * 1.2;


          }
if (rect1.bottom +6 > rect2.top - wallThickness && rect1.top < rect2.top -15&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {


}else{
  
  
}

          
          if (rect1.bottom +3 > rect2.top - wallThickness && rect1.top+6 < rect2.top -5&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {
if(gravity==0){
            top -= power*speed}else{
              top -= power-0.10
            }
//VelocityY = -0.2;
           // console.log("ok")



          } else {

          }
          if (rect1.bottom + 1 > rect2.top - wallThickness && rect1.top < rect2.top && rect1.right > rect2.left + wallThickness && rect1.left < rect2.right - wallThickness) {



            
          } else {
            Topcol = 0;
          }
       /*  if (player.x < rect2.x && player.y + 55 > rect2.y && player.y < rect2.y + 55) {
            rect2.x = player.x - 50;
          }*/

          if (rect1.bottom + 5 >= rect2.top &&
            rect1.top < rect2.bottom &&
            rect1.right > rect2.left &&
            rect1.left < rect2.right) {
            collide = 1;

            cav = 0
            
          } else {
            collide = 0;

          }


        }
          }


          let vi2=0
          // Check if the tile is within the viewport element
          
          if(vi==1){
            
          if (
            tileRect.top+2*tileSize >= viewportRect.top &&
            tileRect.left +2*tileSize  >= viewportRect.left&&
            tileRect.bottom-2*tileSize <= viewportRect.bottom &&
            tileRect.right-2*tileSize <= viewportRect.right
          ) {
            vi2=0
            
          }else{
            vi2=1
            tile.dataset.bugfix1=0
          }
          }
          if(vi2==0){
            
            // Get or set direction
            if (!tile.dataset.direction) {
                tile.dataset.direction = Math.random() * 360; // Initial random direction in degrees
            }

            const directionInRadians = (parseFloat(tile.dataset.direction) * Math.PI) / 180;

            // Calculate new position based on direction
            
if(detectanabled==1){
  tile.classList.add('detect')
}



function hasCollision(class1, class2) {
    const elements1 = document.querySelectorAll(`.${class1}`);
    
    const elements2 = document.querySelectorAll(`${class2}`);

    for (const element1 of elements1) {
        const rect1 = element1.getBoundingClientRect();

        for (const element2 of elements2) {
            const rect2 = element2.getBoundingClientRect();

            if (
                rect1.bottom >= rect2.top &&
                rect1.top <= rect2.bottom &&
                rect1.right >= rect2.left &&
                rect1.left <= rect2.right
            ) {
                return true; // Collision detected
            }
        }
    }

    return false; // No collision found
}




if(hasCollision('detect',collisionobject)){
  alert("")
}









if(tile.dataset.bugfix1>5){
            // Calculate distance using Pythagorean theorem
            

            // Initialize HP if not already set
            
if(hurt==1){
  tile.classList.add('hurtblock');
}
            // Check if the tile is within the specified area
            if (isWithinArea(left / tileSize, top / tileSize, area)) {
                if (movementType === 'follow' && distanceToPlayer <= distance) {
                    // Logic for following the player
                    left += Math.cos(directionInRadians) * speed;
                    top += Math.sin(directionInRadians) * speed;
                } else if (movementType === 'avoid' && distanceToPlayer <= distance) {
                    // Logic for avoiding the player
                    left -= Math.cos(directionInRadians) * speed;
                    top -= Math.sin(directionInRadians) * speed;
                } else if (randomMovement === 1 && distanceToPlayer > distance) {
                    // Logic for random movement when outside the player's distance
                    let randomDirection = parseFloat(tile.dataset.randomDirection); // Get or set random direction from dataset

                    if (!randomDirection || Math.floor(Math.random() * 12) === 2) {
                        // If randomDirection is not defined or random condition is met, generate a new random direction
                        randomDirection = Math.random() * 360;
                        tile.dataset.randomDirection = randomDirection; // Save the generated direction in dataset
                    }

                    left += Math.cos(randomDirection * Math.PI / 180) * speed;
                    top += Math.sin(randomDirection * Math.PI / 180) * speed;
                }
if (randomMovement === 3 && movementType === 'move') {
    let firstX = tile.dataset.firstX ? parseFloat(tile.dataset.firstX) : 0;
    let firstY = tile.dataset.firstY ? parseFloat(tile.dataset.firstY) : 0;

let one=0
if (tile.dataset.firstY !== 0&&tile.dataset.firstY !== undefined) {
  one = 1
}
if(one==0){
  tile.dataset.firstX=left/tileSize
  tile.dataset.firstY=top/tileSize
  
}
console.log(tile.dataset.firstY)
    let currentPositionIndex = tile.dataset.gotopozindex ? parseInt(tile.dataset.gotopozindex) : 0;
    let [x, y] = arena[currentPositionIndex];

    // Oblicz nową docelową pozycję
    let targetX = firstX + x;
    let targetY = firstY + y;
    tile.dataset.targetX=targetX
    tile.dataset.targetY=targetY
console.log("t",targetX)
    if (left / tileSize === targetX && top / tileSize === targetY) {
        // Obiekt już jest na docelowej pozycji, przejdź do kolejnego indexu
        currentPositionIndex = (currentPositionIndex + 1) % arena.length;

        // Sprawdź, czy indeks przekroczył długość areny, jeśli tak, ustaw na 0
        if (currentPositionIndex >= arena.length) {
            currentPositionIndex = 0;
        }

        [x, y] = arena[currentPositionIndex];

        // Zapisz aktualny indeks do datasetu
        tile.dataset.gotopozindex = currentPositionIndex;

        // Aktualizuj pierwsze pozycje na bieżącą pozycję
        tile.dataset.firstX = left / tileSize;
        tile.dataset.firstY = top / tileSize;
    }

    // Obiekt nie dotarł jeszcze na docelową pozycję, kontynuuj ruch w jej kierunku
    if (left / tileSize < targetX) {
        left += speed;
    } else if (left / tileSize > targetX) {
        left -= speed;
    }
    if (top / tileSize < targetY) {
        top += speed;
    } else if (top / tileSize > targetY) {
        top -= speed;
    }

    // Dodatkowa logika dla kolizji, ataku i zmiany kierunku
    // ...

    // Ustaw nową pozycję
    tile.style.left = left + "px";
    tile.style.top = top + "px";
}



                // Check for collision

                // Check for attack


                // Set the new position
                tile.style.left = left + "px";
                tile.style.top = top + "px";

                // Change direction randomly after a certain time
                if (Math.random() < 0.1) { // Adjust the probability as needed
                    tile.dataset.direction = Math.atan2(playerY - top / tileSize, playerX - left / tileSize) * (180 / Math.PI);
                }
            } else {
                // Tile is outside the specified area, move towards the edge of the area
               // console.log(JSON.stringify(tileConfig[tileId]))
                const [x1, y1, x2, y2] = area;
                if (left / tileSize < x1) {
                    left += speed;
                } else if (left / tileSize > x2) {
                    left -= speed;
                }
                if (top / tileSize < y1) {
                    top += speed;
                } else if (top / tileSize > y2) {
                    top -= speed;
                }

                // Set the new position
                tile.style.left = left + "px";
                tile.style.top = top + "px";
                
if (deletebool == true) {
  deletedtiles.push(tile);
//console.log(JSON.stringify(tileConfig[tileId]))
//console.log(JSON.stringify(tileConfig[tileId]))
  // Remove 
  // Entity is defeated, remove the tile
  tile.remove();
}
            }}}
        });
    }}

    // Request the next animation frame
    // ...
}
if (stop === 1) {
  for (const tileId in tileConfig) {
    var tiles = document.querySelectorAll(`.${tileId}`);

    tiles.forEach((tile) => {
     /* tile.removeAttribute('gotopozindex');
      tile.removeAttribute('firstX');
      tile.removeAttribute('firstY');*/
      //tile.remove()
      //console.log(tile);
    });

    
  }
}

}
// Function to check if a point is within the specified area
function isWithinArea(x, y, area) {
    const [x1, y1, x2, y2] = area;
    return x >= x1 && x <= x2 && y >= y1 && y <= y2;
}


var attack=0;
function attack2(){
  attack=1
  setTimeout(function(){
    attack=0
    //alert("")
  },100)
}

// Call this function to move .tile1 elements randomly
//window.setInterval(moveTilesRandomly,2)


// ... (your existing code)

document.getElementById('addButton').addEventListener('click', openFileInput);

function openFileInput() {
  const fileInput = document.getElementById('imageInput');
  fileInput.click();
}

document.getElementById('imageInput').addEventListener('change', handleFileSelect);

function handleFileSelect(event) {
  const fileInput = event.target;
  const files = fileInput.files;

  if (files.length > 0) {
    const newBlockIndex = TILES.length; // Get the next iteration
    const collisionValue = 1;
    const image = event.target.files[0];
    
    // Create file reader object
    const reader = new FileReader()
    
    // Convert image to data URL
    reader.readAsDataURL(image)
    
    reader.addEventListener('load', () => {
          TILES.push([newBlockIndex, collisionValue, reader.result,thistilesize,translateY]);
          TILES.push([TILES.length,1,"/ NAN.png"])
    })
    updateViewport();
  }
}
/*input.addEventListener('change', (event) => {
  const image = event.target.files[0]

  // Create file reader object
  const reader = new FileReader()

  // Convert image to data URL
  reader.readAsDataURL(image)

  reader.addEventListener('load', () => {
    // Save data URL to local storage
    localStorage.setItem('thumbnail', reader.result)
  })
})*/

let vcc238=0
function moveObjectsDown() {
  
  if(vcc238==0){
    vcc238=1
  let X=0
  let Y=1
  
  for (let dimension = 0; dimension < tileMap.length; dimension++) {
    for (let i = 0; i < tileMap[dimension].length; i++) {
      
      tileMap[dimension][i][0] += X; 
      tileMap[dimension][i][1] += Y; 
      
    }
  }
  setTimeout(function(){
    vcc238=0
  },1000)
  }
}





document.getElementById('addButton2').addEventListener('click', openFileInput2);

function openFileInput2() {
  const fileInput = document.getElementById('imageInput2');
  fileInput.click();
}

// Handle file selection
document.getElementById('imageInput2').addEventListener('change', handleFileSelect2);

function handleFileSelect2(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  
  if (files.length > 0) {
    const newBlockIndex = TILES.length; // Get the next iteration
    const collisionValue = 0;
    const image = event.target.files[0];
  
    // Create file reader object
    const reader = new FileReader()
  
    // Convert image to data URL
    reader.readAsDataURL(image)
  
    reader.addEventListener('load', () => {
      TILES.push([newBlockIndex, collisionValue, reader.result,thistilesize,translateY]);
      TILES.push([TILES.length,1,"/ NAN.png"])
    })
    updateViewport();
  }
}


document.getElementById('addButton5').addEventListener('click', openFileInput5);

function openFileInput5() {
  const fileInput = document.getElementById('imageInput5');
  fileInput.click();
}

// Handle file selection
document.getElementById('imageInput5').addEventListener('change', handleFileSelect5);

function handleFileSelect5(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  
  if (files.length > 0) {
    const newBlockIndex = TILES.length; // Get the next iteration
    const collisionValue = 2;
    const image = event.target.files[0];
  
    // Create file reader object
    const reader = new FileReader()
  
    // Convert image to data URL
    reader.readAsDataURL(image)
  
    reader.addEventListener('load', () => {
      TILES.push([newBlockIndex, isentity, reader.result,thistilesize,translateY]);
      TILES.push([TILES.length,1,"/ NAN.png"])
    })
    updateViewport();
  }
}


document.getElementById('addButton3').addEventListener('click', openFileInput3);

function openFileInput3() {
  const fileInput = document.getElementById('imageInput3');
  fileInput.click();
}
var playerskin=config.playerskin1
// Handle file selection
document.getElementById('imageInput3').addEventListener('change', handleFileSelect3);

function handleFileSelect3(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  
  if (files.length > 0) {
    const newBlockIndex = TILES.length; // Get the next iteration
    const collisionValue = 1;
    const image = event.target.files[0];
  
    // Create file reader object
    const reader = new FileReader()
  
    // Convert image to data URL
    reader.readAsDataURL(image)
  
    reader.addEventListener('load', () => {
      
      document.querySelector('.player').style.background=`url(${reader.result})`
playerskin=reader.result
    updateViewport();
  
      
    })
    
  }

}




document.getElementById('addButton4').addEventListener('click', openFileInput4);

function openFileInput4() {
  const fileInput = document.getElementById('imageInput4');
  fileInput.click();
}
var bgimg="/grass"
// Handle file selection
document.getElementById('imageInput4').addEventListener('change', handleFileSelect4);

function handleFileSelect4(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  
  if (files.length > 0) {
    const newBlockIndex = TILES.length; // Get the next iteration
    const collisionValue = 1;
    const image = event.target.files[0];
  
    // Create file reader object
    const reader = new FileReader()
  
    // Convert image to data URL
    reader.readAsDataURL(image)
  
    reader.addEventListener('load', () => {
  
  
  
  config.bg = reader.result
  var contentElement = document.getElementById("content");
  contentElement.style.backgroundImage = `url('${config.bg}')`;
  bgimg = reader.result
  
  
      
      updateViewport();
  
  
    })
  
  }
}


  




// Inicjalizacja
updateViewport();
function scrollPage() {
  viewport.scrollBy(0, 0); // Przesuń stronę o 0 pikseli w dół
}
setInterval(scrollPage, 1);






var last = TILES[TILES.length - 1][2]




</script>

<p style="position:fixed; bottom: 0px; left:50vw; transform: translate(-50%,0%); z-index: 99999; color:white">killed: <t id="killed"></t></p>
<p style="position:fixed; bottom: 0px; left:calc(50vw + 80px); transform: translate(-50%,0%); z-index: 99999; color:white">score: <t id="score"></t></p>
<script>
function test00(){
  document.getElementById('killed').innerHTML=killed
  document.getElementById('score').innerHTML=score
}
window.setInterval(test00,1000)
</script>




<script>
  var fps = document.getElementById("fps");
var startTime = Date.now();
var frame = 0;
function tick() {
  var time = Date.now();
  frame++;
  if (time - startTime > 1000) {
    fps.innerHTML = (frame / ((time - startTime) / 1000)).toFixed(1);
    startTime = time;
    frame = 0;
  }
  
  window.setTimeout(tick,200);
}
tick();
</script>
<script>
var gravity=config.gravity;
    var stick = document.querySelector('.stick');
    var joystick = document.querySelector('.joystick');
    var joystickRect = joystick.getBoundingClientRect();
    let isDragging = false;
    let joystickX = 0;
    let joystickY = 0;
    var x=0
    var y=0
    var speed=config.speed
  function movright(){
    movePlayer(-0.08*speed,0)
  }
  function movleft() {
    movePlayer(0.08*speed,0)
  }
  function movup() {
movePlayer(0,-0.08*speed)
  }
  function movdown() {
    movePlayer(0,0.06*speed)
  }
    function updateJoystick(event) {
      let x, y;
      if (event.type === 'touchmove') {
        x = event.touches[0].clientX - joystickRect.left - joystickRect.width / 2;
        y = event.touches[0].clientY - joystickRect.top - joystickRect.height / 2;
      } else {
        x = event.clientX - joystickRect.left - joystickRect.width / 2;
        y = event.clientY - joystickRect.top - joystickRect.height / 2;
      }
      if (x > 30) {
        movleft()
      }
      if (x < 30) {
        movright()
      }
      const distance = Math.sqrt(x * x + y * y);
      const angle = Math.atan2(y, x);
      const maxDistance = joystickRect.width / 2 - stick.getBoundingClientRect().width / 2;
      if (y < -40 && distance > 40) {
        movup()
      }
      if (y > 40 && distance > 40) {
       movdown()
      }
      if (distance > maxDistance) {
        x = Math.cos(angle) * maxDistance;
        y = Math.sin(angle) * maxDistance;
      }
      stick.style.transform = `translate(${x}px, ${y}px)`;
    }
    stick.addEventListener('mousedown', event => {
      isDragging = true;
      updateJoystick(event);
    });
    joystick.addEventListener('mousemove', event => {
      if (isDragging) {
        updateJoystick(event);
      }
    });
    joystick .addEventListener('mouseup', () => {
      isDragging = false;
      stick.style.transform = 'translate(0px, 0px)';
    });

    stick.addEventListener('touchstart', event => {
      event.preventDefault();
      isDragging = true;
      if(toonce===0){
      aud = document.getElementById('audio')
      aud.play()
      aud.loop = true;
      if(aud.currentTime >0){
      toonce=1
      }
      aud.currentTime = 0;
      }
      updateJoystick(event);
    });
    joystick.addEventListener('touchmove', event => {
      event.preventDefault();
      if (isDragging) {
        updateJoystick(event);
      }
    });
    joystick .addEventListener('touchend', () => {
      isDragging = false;
      stick.style.transform = 'translate(0px, 0px)';
    });
</script>
<script>
const limitIteracji = 50;
var classicspeed=config.norspeed
let test2=0
var newcollisions = [".hurtblock"];
function checkit() {
  
  for (let tileClass of newcollisions) {
    const tiles = document.querySelectorAll(tileClass);
//console.log(JSON.stringify(tiles))
    for (let tile of tiles) {
      const rect1 = player.getBoundingClientRect();
      const rect2 = tile.getBoundingClientRect();
      const wallThickness = 2;

      if (rect1.bottom > rect2.top - 5 &&
        rect1.top < rect2.bottom + 5 &&
        rect1.right > rect2.left - 5 &&
        rect1.left < rect2.right + 5) {
        
          
playerY=config.spawnY
playerX=config.spawnX
        
      }
    }
  
  }
}




function normspeed() {
  const nearestDistanceThreshold = 25; // Adjust this threshold as needed
  let nearestDistance = Number.MAX_SAFE_INTEGER;

  for (let tile of tiles) {
    const rect1 = player.getBoundingClientRect();
    const rect2 = tile.getBoundingClientRect();

    const distance = Math.sqrt(
      Math.pow(rect1.left - rect2.left, 2) +
      Math.pow(rect1.top - rect2.top, 2)
    );

    if (distance < nearestDistance) {
      nearestDistance = distance;

      if (rect1.bottom > rect2.top - 90 &&
        rect1.top < rect2.bottom + 90 &&
        rect1.right > rect2.left - 90 &&
        rect1.left < rect2.right + 90) {
        if (!(rect1.bottom > rect2.top - 80 &&
            rect1.top < rect2.bottom + 80 &&
            rect1.right > rect2.left - 80 &&
            rect1.left < rect2.right + 80)) {
          speed = classicspeed;
          //alert("")
        }
      } else {

      }
    }
  }
  test2 += 1
  if (test2 < 8) {
    setTimeout(normspeed, 500)
  } else {
    test2 = 0
  }
}

function jump(){
  
  speed=4
  
  setTimeout(function(){
    speed=config.backspeed
    power=0.20
  },5000)
}
function jump2(){
  if(canJUMP==1){
  jumping()
  }
}
let gjfj=0
let olderspeed=0

const player = document.querySelector('.player');
player.style.willChange = 'transform';
var tileSize2 = tileSize;
let playerX = config.px*30;
let playerY = config.py*30;
// Przewiń stronę do określonej pozycji
viewport.scrollTo( 100, 100) 
setTimeout(function(){
  if(config.customcamera==1){
    viewport.scrollTo( config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight* viewportHeight/2) 
  }
})
var thix=0
var thiy=0
function movePlayer(dx, dy) {
  playerX += dx;
  thiy=dy;
  thix=dx;
  playerY += dy;
  
  document.getElementById('console').innerHTML ='x:'+ Math.round(playerX*100)/100 +' &nbsp &nbsp &nbsp y:'+Math.round(playerY*100)/100

  player.style.left = playerX * tileSize2 + 'px';
  player.style.top = playerY * tileSize2 + 'px';
  
}
function setPlayer(dx, dy) {
  playerX = dx;
  thiy = dy;
  thix = dx;
  playerY = dy;

  document.getElementById('console').innerHTML = 'x:' + (playerX) + 'y:' + (playerY)

  player.style.left = playerX * tileSize2 + 'px';
  player.style.top = playerY * tileSize2 + 'px';

}
setTimeout(move, 2)
checkIfElementExited(player, viewport)
function move(){
  
}
function checkIfElementExited(player, viewport) {

  viewport.scrollTo((playerX * tileSize2) - viewportWidth / 2, (playerY * tileSize2) - viewportHeight / viewportHeight* viewportHeight/2)
  
}
// Przykład użycia
// Przykład użycia
var power=0.20
var tiles = document.querySelectorAll('.tile');
  function constructn(){
     tiles = document.querySelectorAll('.tile5 , .tile');
  }
var topside=0

var to1=0
check()
function check(){
  for (let tile of tiles) {
    const rect1 = player.getBoundingClientRect();
    const rect2 = tile.getBoundingClientRect();
    const wallThickness = 2;
  
    if (rect1.bottom > rect2.top - 1 &&
      rect1.top < rect2.bottom + 1 &&
      rect1.right - 1 > rect2.left - 1 &&
      rect1.left < rect2.right + 1) {
  to1+=1
  //alert(to1)
      cofnijczas(to1)
     // console.log("oh")
      //alert("he")
      //    VelocityY = -0.01;
      Centercol = 1;
      topside = 0;
      /*   playerY -= 0.6;*/
    //  playerX -= 0.1;
    }else{
      setTimeout(function(){
        to1=1
      },1000)
    }
  }
//  requestAnimationFrame(check)
}
/*
if (rect1.bottom > rect2.top - 5 &&
rect1.top < rect2.bottom + 5 &&
rect1.right > rect2.left - 5 &&
rect1.left < rect2.right + 5) {
*/
      function collision() {
        if( config.debugmode==0 && isgamepaused==0 ) {
        for(let i=0; i<2;i++){
        for (let tile of tiles) {
          const rect1 = player.getBoundingClientRect();
          const rect2 = tile.getBoundingClientRect();
          const wallThickness = 2;
          
          if (rect1.bottom > rect2.top + 5 &&
            rect1.top < rect2.bottom - 10 &&
            rect1.right + 5 > rect2.left + 5 &&
            rect1.left < rect2.right - 5) {
              
            //  cofnijczas(2)
           // console.log("oh")
        //    collision()
        //    VelocityY = -0.01;
            Centercol = 1;
            topside = 0;
         /*   playerY -= 0.6;*/
         //   playerX -= 0.1;
         speed=config.backspeed
         setTimeout(normspeed,1000)
          } else {

            Centercol = 0

          }
          if (rect1.top < rect2.bottom + 3 && rect1.bottom > rect2.bottom + 3 && rect1.right > rect2.left && rect1.left < rect2.right) {
          
            playerY +=power * speed;

            player.style.top = playerY * tileSize + 'px';
          
        //    collide = 1
        speed=config.backspeed
            setTimeout(normspeed,1000)
          }
          if (rect1.left +3< rect2.right + wallThickness && rect1.right > rect2.right && rect1.bottom > rect2.top  && rect1.top < rect2.bottom ) {

            playerX += power*speed;

            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';

            collide = 1
            speed=config.backspeed
            setTimeout(normspeed,1000)
          }
          if (
              rect1.right > rect2.left - 3 &&
              rect1.left < rect2.left &&
              rect1.bottom > rect2.top &&
              rect1.top < rect2.bottom
            ) {



            // blokuje poruszanie x
            // lewa scianka 
            playerX -= power * speed * 1.2;


            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';

            collide = 1
            speed = config.backspeed
            setTimeout(normspeed, 1000)
          }
if (rect1.bottom +6 > rect2.top - wallThickness && rect1.top < rect2.top -15&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {

canJUMP=1

}else{
  
  
}

          
          if (rect1.bottom +3 > rect2.top - wallThickness && rect1.top+6 < rect2.top -5&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {
if(gravity==0){
            playerY -= power*speed}else{
              playerY -= power-0.10
            }
//VelocityY = -0.2;
           // console.log("ok")


            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';

  //          VelocityY = 0;

            speed=config.backspeed
            setTimeout(normspeed,1000)
          } else {

          }
          if (rect1.bottom + 1 > rect2.top - wallThickness && rect1.top < rect2.top && rect1.right > rect2.left + wallThickness && rect1.left < rect2.right - wallThickness) {


          //  console.log("jump")
            // blokuje poruszanie x
            spgrav = 0

            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';
speed=config.backspeed
setTimeout(normspeed,1000)
            Topcol = 1
            
          } else {
            Topcol = 0;
          }
       /*  if (player.x < rect2.x && player.y + 55 > rect2.y && player.y < rect2.y + 55) {
            rect2.x = player.x - 50;
          }*/

          if (rect1.bottom + 5 >= rect2.top &&
            rect1.top < rect2.bottom &&
            rect1.right > rect2.left &&
            rect1.left < rect2.right) {
            collide = 1;

            cav = 0
            
          } else {
            collide = 0;

          }


        }}
      }}
function h(){
  
}
var by3=0

      function anim() {
        by3++;
        if (isScrolling && by3 > 17) {
          by3 = 0
          updateViewport();
          isScrolling = false;
        
        }
        var tile2ps = document.getElementsByClassName("tile1");
        
        for (var i = 0; i < tile2ps.length; i++) {
          tile2ps[i].Timeout = function() {
            this.timetorm += 1;
            if (this.timetorm > 90) {
              this.remove();
            }
          };
          
          tile2ps[i].move = function() {
            var posX = parseFloat(this.style.left);
            var posY = parseFloat(this.style.top);
          
            posX += 2 * tileSize;
            posY += 2 * tileSize;
          
            this.style.left = posX + 'px';
            this.style.top = posY + 'px';
          }; 
          
        }
        constructn()
      }
      let toto=0;
      let defaultFps = 30;
let targetFPS = 30;
let iindex = 0;
let frameTime = 1000 / targetFPS;

function loop() {
    checkit();
    if (toto > 1) {
        toto = 0;
    }
    if (toto == 0) {
        moveTilesRandomly();
    }
    toto += 1;
    if (config.debugmode == 0) {
        if (config.sidescroll == 1) {
            checkIfElementExited(player, viewport);
        }
    } else {
        checkIfElementExited(player, viewport);
    }
    if (downButtonDown == 1) {
        movdown();
    }
    if (leftButtonDown == 1) {
        movright();
    }
    if (upButtonDown == 1) {
        movup();
    }
    if (rightButtonDown == 1) {
        movleft();
    }
    if (movePlayer(0, 0)) {
    } else {
        thix = 0;
        thiy = 0;
    }
    stick = document.querySelector('.stick');
    joystick = document.querySelector('.joystick');
    joystickRect = joystick.getBoundingClientRect();
    collision();
    if (gravity == 1) {
        playerY += config.gravitypower||0.10;
    }


    anim(); // Wywołaj anim

    // Wywołaj pętlę gry ponownie przy użyciu requestAnimationFrame
    setTimeout(() => {
        requestAnimationFrame(loop);
    }, frameTime);
}

function jumping() {
    canJUMP = 0;
    gravity = 0;
    olderspeed = speed;
    gjfj += 1;
   // speed = 1.0;
    playerY -= config.jumpingpower;

    if (gjfj < config.longjump) {
        requestAnimationFrame(jumping);
    } else {
        gjfj = 0;
        speed = olderspeed;
        gravity = 1;
    }
}

// Rozpocznij pętlę gry
requestAnimationFrame(loop);
requestAnimationFrame(loop);



var brushSize = 1; // Ustaw rozmiar pędzla

function buildBlock(event) {
  // Oblicz pozycję kliknięcia z uwzględnieniem aktualnej translacji viewport
  const rect = content.getBoundingClientRect();
  const x = Math.floor((event.clientX - rect.left) / tileSize2);
  const y = Math.floor((event.clientY - rect.top) / tileSize2);

  // Funkcja do zbudowania bloków w obszarze o określonym rozmiarze
  function buildBlocksAroundPosition(startX, startY) {
    if(config.testmode==0){
  for (let offsetX = -brushSize + 2; offsetX <= brushSize; offsetX++) {
    for (let offsetY = -brushSize + 2; offsetY <= brushSize; offsetY++) {
      const currentX = startX + offsetX - 1;
      const currentY = startY + offsetY - 1;

      const existingBlockIndex = tileMap[dimension].findIndex(tile => tile[0] === currentX && tile[1] === currentY);

      if (layers === 0) {
        if (existingBlockIndex !== -1) {
          // Jeśli blok istnieje, usuń go
          tileMap[dimension].splice(existingBlockIndex, 1);
        } else {
          // Jeśli blok nie istnieje, dodaj nowy blok
          tileMap[dimension].push([currentX, currentY, item]); // Zakładając, że 1 reprezentuje blok, dostosuj, jeśli trzeba
        }
      } else {
        // Warstwy są włączone, dodaj blok bez usuwania
        tileMap[dimension].push([currentX, currentY, item]);
      }
    }
  }

  // Wywołaj funkcję budującą bloki wokół klikniętej pozycji
  updateViewport();
    }
}

  // Wywołaj funkcję budującą bloki wokół klikniętej pozycji
  buildBlocksAroundPosition(x, y);

  updateViewport();
}

dld()
function dld(){
//  console.log(JSON.stringify(tileMap))
  setTimeout(dld,4000)
}
content.addEventListener('click', buildBlock);





// Add these Vables at the beginning of your script

const maxHistoryLength = 20;


function upd10() {
  // Your existing code for moving the player

  // Add the current position to the history array
  lastplayerpos.push({ x: playerX, y: playerY });

  // Ensure the history array does not exceed the maximum length
  if (lastplayerpos.length > maxHistoryLength) {
    lastplayerpos.shift(); // Remove the oldest element
  }

  // Rest of your existing code
}
window.setInterval(upd10,1000)
// Add the cofnijczas function to rewind the player position
function cofnijczas(ilerazycofnac) {
  for (let i = 0; i < ilerazycofnac; i++) {
    if (lastplayerpos.length > 1) {
      const previousPos = lastplayerpos.pop(); // Get the previous position
      playerX = previousPos.x;
      playerY = previousPos.y;

      // Update the player's visual position
      player.style.left = playerX * tileSize2 + 'px';
      player.style.top = playerY * tileSize2 + 'px';
    }
  }
}


</script> 


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Counter</title>
    <style>
        #fpsCounter {
            position: fixed;
            z-index: 9999;
            top: 0;
            left: 0;
            padding: 10px;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="notaproject" id="fpsCounter"></div>

    <script>
        const fpsCounter = document.getElementById('fpsCounter');
        let frameCount = 0;
        let lastTimestamp = performance.now();

        function updateFPS() {
            const currentTimestamp = performance.now();
            const elapsedMilliseconds = currentTimestamp - lastTimestamp;
            const elapsedSeconds = elapsedMilliseconds / 1000;

            const fps = Math.round((frameCount / elapsedSeconds));

            fpsCounter.textContent = `FPS: ${fps}`;

            frameCount = 0;
            lastTimestamp = currentTimestamp;

            requestAnimationFrame(updateFPS);
        }

        function animate() {
            frameCount++;
            requestAnimationFrame(animate);
        }

        updateFPS();
        animate();
    </script>
</body>
</html>


<gui>
  <div class="btns">
    <div class="null added"></div>
    <div class="btn added" id="Up"></div>
    <div class="null added"></div>
    <div class="btn added" id="Left"></div>
    <div class="null added"></div>
    <div class="btn added" id="Right"></div>
    <div class="null added"></div>
    <div class="btn added" id="Down"></div>
    <div class="null added"></div>
  
  </div>
</gui>

<style>
  .btn{
    width:40px;
    height: 40px;
    background: #6F6F6FA1;
    margin:5px;
    float:left;
  }
  .null {
      width: 40px;
      height: 40px;
      background: #00000000;
      margin: 5px;
      float:left;
    }
    gui{
      position: abso;
      width:100vw;
      height:100vh;
      z-index 20;
    }
.btns{
  zoom: 1;
  position: absolute;
  bottom: 20px;
  left:10px;
  width: 150px;
}
</style>
</body>

</html>
<script>
function testy() {
  config.guiHTML = document.querySelector('gui').innerHTML;
//  config.guiHTML2 = document.querySelector('#project2').innerHTML;
  console.log(config.guiHTML);
}

function testa() {
  setTimeout(function () {
    if (config.customGUI == 1) {
      const elementyDoUsuniecia = document.querySelectorAll('.added');
      elementyDoUsuniecia.forEach(function (element) {
        element.remove();
      });
      document.querySelector('gui').innerHTML = config.guiHTML;
      document.querySelector('#project2').innerHTML = config.guiHTML2;
      if (document.getElementById('Left')) {
        document.getElementById('Left').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          leftButtonDown = 1;
        });

        document.getElementById('Left').addEventListener('touchend', function () {
          leftButtonDown = 0;
        });
      }

      if (document.getElementById('Right')) {
        document.getElementById('Right').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          rightButtonDown = 1;
        });

        document.getElementById('Right').addEventListener('touchend', function () {
          rightButtonDown = 0;
        });
      }

      if (document.getElementById('Up')) {
        document.getElementById('Up').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          upButtonDown = 1;
        });

        document.getElementById('Up').addEventListener('touchend', function () {
          upButtonDown = 0;
        });
      }
      
      if (document.getElementById('Down')) {
        document.getElementById('Down').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          downButtonDown = 1;
        });

        document.getElementById('Down').addEventListener('touchend', function () {
          downButtonDown = 0;
        });
      }

      var jumpElement = document.getElementById('Jump');

      if (jumpElement) {
        jumpElement.addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          jump2();
        });
      }

      var atackelement = document.getElementById('Attack');

      if (atackelement) {
        atackelement.addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          attack2();
        });
      }
    }
  }, 1000);
}

testa();
window.setInterval(testy, 3000);

</script>





<!-- Building -->

<style>
  #container123{
    position: absolute; top:0;right:0;zoom:0.7
  }
  .box0{ width:50px;height:60px;background: #6F6F6F; float: left; margin:4px; justify-content: center; align-items: center ; display: flex; font-size: 30px}
  .box1{ width:50px;height:60px;background: #ACACAC; float: left; margin:4px; justify-content: center; align-items: center ; display: flex; font-size: 30px}
  
</style>
<div id="container123" class="notaproject d dr">
  <div id="add123" class="box0" onclick="add123()"   >+</div>
  <div id="value123" class="box1"                      ></div>
  <div id="sub123" class="box0" onclick="sub123()"   >-</div>
</div>
<script>
  var item=1;function add123(){ if(item > -1 ){ item ++ ; updt()}}function sub123(){if(item > 0 ){ item -- ; updt()}}function updt(){document.getElementById('value123').innerText=item}
</script>

<!-- dimensions -->

<style>
  #container1232{
    position: absolute; top:0px;right:55px
    ;zoom:0.7;
    
  }
.d{
  z-index: 999999
}
</style>
<div id="container1232" class="notaproject d dr">
  <div  class="box0" onclick="add1232()"   >+</div>
  <div id="value1232" class="box1"                      ></div>
  <div class="box0" onclick="sub1232()"   >-</div>
</div>
<script>
  function add1232(){ if(dimension > -1 ){ dimension ++ ; updt2()}}function sub1232(){if(dimension > 0 ){ dimension -- ; updt2()}}function updt2(){document.getElementById('value1232').innerText=dimension; updateViewport()}
</script>


<!-- brushSize -->

<style>
  #container1233{
    position: absolute; top:0px;right:110px;zoom:0.7
  }

</style>
<div id="container1233" class="notaproject d dr">
  <div  class="box0" onclick="add1233()"   >+</div>
  <div id="value1233" class="box1"                      ></div>
  <div class="box0" onclick="sub1233()"   >-</div>
</div>
<script>
  function add1233(){ if(brushSize > -1 ){ brushSize ++ ; updt3()}}function sub1233(){if(brushSize > 0 ){ brushSize -- ; updt3()}}function updt3(){document.getElementById('value1233').innerText=brushSize; updateViewport()}
</script>



<div id="toggleButton" style="width:50px;height:60px;background: #6F6F6F; float: left; margin:4px; justify-content: center; align-items: center ; display: flex; position:absolute;font-size: 10px"onclick="toggleLayers()" class="notaproject">TL</div>
<script>
  let layers = 0;

function toggleLayers() {
  layers = 1 - layers; // Przełącz między 0 a 1
  const button = document.getElementById('toggleButton');
  
  if (layers === 1) {
    // Zmiana koloru na zielony po aktywowaniu
    button.style.backgroundColor = 'green';
  } else {
    // Powrót do domyślnego koloru
    button.style.backgroundColor = ' #6F6F6F'; // Ustaw na pusty string, aby skorzystać z domyślnego koloru przycisku
  }
//alert(layers)
  // Tutaj możesz umieścić dodatkową logikę związaną z przełączaniem warstw (layers)
  // np. zmiana mapy w zależności od wartości layers
}

</script>


  <style>
.menu-container {position: absolute;bottom: 15%;width:0%;height:0%;right: 15%;text-align: center;display: block;}.menu-content {background-color: #F0F0F0;padding: 5px;position: fixed;z-index:2;border: 1px solid #ccc;display: none;top: 50%;left: 50%;transform: translate(-50%,-50%);
  width:60%;height:60%;overflow: hidden; overflow: scroll;
}.menu-toggle {cursor: none;border-radius: 100%;background-color: #4CAF50;color: white;padding: 20px 20px;border: none; position: fixed; bottom: 50%; left:0px; z-index: 99999;}.menu-toggle:hover {background-color: #45a049;}.menu-container:hover .menu-content {display: block;} .mn div{ cursor: none;background-color: #4caf50;color: white;padding: 5px 20px;border: none;width:calc(100% - 0px);}

.menu2-content {background-color: #0E0E0E;padding: 5px;position: fixed;border: 1px solid #1C1C1C;top: 50%;left: 50%;transform: translate(-50%,-50%);
  width:95%;height:95%;overflow: hidden; 
  color:white;
}
.menu0-content {background-color: #C4C4C4;padding: 5px;position: absolute;border: 1px solid #EDEDED;top: 50%;left: 50%;transform: translate(-50%,-50%);
  width:80%;height:80%;overflow: hidden; overflow: scroll;
  
}
.closebutton{
  width: 20px;
  height:20px;
  justify-content: center; 
  align-items: center;
  display: flex;
  background: #8F3434;
  border-radius: 20%;
}
  </style>
</head>
<body>
  



<style>
  
</style>
<div style="position: absolute; top:50vh; left:50vw; transform: translate(-50%,-50%); width: 90%; height:80%; background: black; padding: 10px; z-index: 9999;"class="entitymenu">
<div onclick="togglemenu()">
  close menu
</div>
</div>
  
  <div class="menu-container notaproject">
    <div class="menu-content">
<pre style="white-space: pre-wrap" class="mn">
  <h3>Menu</h3>
<hr>
<div onclick="visibility('.menu2-content')" style="background: yellow">Code
</div>
<div onclick="toggleVS()" style="background: yellow">
Visuals
</div>
<div onclick="loadfile()" style="background: blue">
  LoadProjectFile
</div>
<div onclick="handleFileContent(JSON.stringify(example2))">
  load example platformer game
</div>
<div onclick="handleFileContent(JSON.stringify(example3))">
  load example Apple Man game
</div>
<div onclick="document.getElementById('tutor').style.display='block'" style="background: gray">
ASM tutor
</div>
<div onclick="topdownbuttonsexmp()">
TopDownGameButtons
</div>
<div onclick="platformergamebuttonexmp()">
  platformergamebuttonexmp
</div>
<div onclick="toggh()" style="background: navy">
  show classes
</div>
<div onclick="rmmake()" style="background: red">
  remove everything make
</div>
  <input type="range" id="mySlider" min="-30" max="30" value="0">
bg size:  <t id="sliderValue" style="color:black;">0</t>
  <script>
  
  
function loadfile() {
  // Utwórz element input typu file
  const input = document.createElement('input');
  input.type = 'file';

  // Dodaj obsługę zdarzenia po wybraniu pliku
  input.addEventListener('change', function() {
    const file = input.files[0];
    toonce = 1;

    if (file) {
      // Odczytaj zawartość pliku jako tekst
      const reader = new FileReader();
      reader.onload = function(e) {
        let textContent = e.target.result;

        // Podejmij dalsze kroki z tekstem pliku
        handleFileContent(textContent);
      };
      reader.readAsText(file);
    }
  });

  // Wywołaj kliknięcie na element input
  input.click();
}

function handleFileContent(textContent) {
  // Tutaj przetwarzaj zawartość pliku tekstowego
  // Możesz pozostawić resztę Twojego kodu, ale już bez konieczności przekształcania na base64

  try {
   
    config = JSON.parse(textContent);
const playerskin69=config.playerskin1
//alert(playerskin69)
document.querySelector('.player').style.background=`url(${playerskin69})`
playerskin=playerskin69
    updateViewport();
  setTimeout(function() {
    if (config.DarknessEffect == 1) {
      let vp = document.getElementById("viewport")
      let el = document.createElement('div')
      el.style = `width:${vp.style.width};height:${vp.style.height};`
      el.className = 'dark effects added'
      document.querySelector('#project').appendChild(el)
    } else {
      let y = document.querySelectorAll('.effects')
      for (var i = 0; i < y.length; i++) {
        if (y[i].classList == 'dark') {
          y[i].remove()
        }
      }
    }
  }, 1000)

    
    
    deletedtiles=[]
    document.getElementById('edytor').textContent=config.code
    stop=1
    code = config.code;
    classicspeed = config.norspeed;
    playerY = config.spawnY;
    playerX = config.spawnX;
   setPlayer(config.spawnX,config.spawnY)
    speed = config.speed;
    playerskin = config.playerskin1;
    TILES = config.blocks;
    tileMap = config.savedTileMap;
    gravity = config.gravity;
    content.style.backgroundSize=(config.bgsize)+"px"
    code=config.code
    if (audioInstance) {
      // Jeżeli istnieje istniejący odtwarzacz audio, zatrzymaj go
      audioInstance.pause();
      audioInstance.currentTime = 0;
      audioInstance = null;
    }
    
    if (config.music !== '') {
      const base64Wav = config.music;
    
      // Utwórz nowy odtwarzacz audio
      audioInstance = new Audio();
      audioInstance.src = base64Wav;
      audioInstance.setAttribute('preload', 'auto');
    
      // Dodaj odtwarzacz do dokumentu
      document.body.appendChild(audioInstance);
    
      // Odtwórz plik audio WAV
      audioInstance.play();
      audioInstance.loop = true;
      toonce = 0;
    }
    
    if (config.customcamera == 1) {
      viewport.scrollTo(config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight * viewportHeight / 2)
    }
    
    const contentElement = document.getElementById("content");
    document.querySelector('gui').innerHTML=config.guiHTML
   ukonczoneGUI()
    contentElement.style.backgroundImage = `url('${config.bg}')`;
    document.getElementById('Scontent').innerHTML=''
    document.getElementById('Econtent').innerHTML=''
    tileConfig = config.entities
    document.getElementById('entitiesconfig').innerText = JSON.stringify(config.entities);
    moveTilesRandomly()
    setTimeout(function(){
      curline=0
      currentLine=0
      generateAllTiles()
       candocmd = 1
       curline = 0
       currentLine = 0;
       candothath = 0
       defy = 0
       jmptimes = 0
      stop=0
      RESET()
    },3000)
//alert(content.style.backgroundSize)
 tileSize = config.tilesize; // Rozmiar pojedynczego kafelk
 cfigZ = config.zoomoff;
 vp = document.getElementById("viewport");
vp.style.zoom = cfigZ*config.zoomadd;

    //alert((config));
  } catch (error) {
    console.error("Błąd podczas parsowania pliku JSON:", error);
  }
}




  function rmmake(){
    document.querySelector('.Scontent').innerHTML=""
  }
const slider = document.getElementById('mySlider'), valueDisplay = document.getElementById('sliderValue');
let diff = 0, currentValue = parseInt(slider.value);
valueDisplay.textContent = currentValue;

slider.addEventListener('input', () => { diff = parseInt(slider.value); valueDisplay.textContent = diff + currentValue; });
slider.addEventListener('touchend', () => { slider.value = 0; currentValue += diff; setTimeout(() => { valueDisplay.textContent = currentValue;config.bgsize=currentValue;content.style.backgroundSize=(config.bgsize)+"px" }, 10); });

setTimeout(function(){
if(config.debugmode==1){
topdownbuttonsexmp()
document.querySelector('.player').style.background = `url('/debug.png')`

updateViewport();

document.querySelector('.player').style.background=`url("${config.playerskin1}");`;
}
},3000)
  </script>
<!--  <input type="range" id="mySlider2" min="-10" max="10" value="0">
blocks size:  <t id="sliderValue2" style="color:black;">0</t>-->
  <script>
const slider2 = document.getElementById('mySlider2'), valueDisplay2 = document.getElementById('sliderValue2');
let diff2 = 0, currentValue2 = 30
valueDisplay2.textContent = currentValue2;

slider2.addEventListener('input', () => { diff2 = parseInt(slider2.value); valueDisplay2.textContent = diff2 + currentValue2; });
slider2.addEventListener('touchend', () => {stop=1; slider2.value = 0; currentValue2 += diff2; setTimeout(() => { valueDisplay2.textContent = currentValue2; }, 10); tileSize=currentValue2;tileSize2=currentValue2; setPlayer(6.5*30,6.5*30);  numVisibleTilesX = Math.ceil(viewportWidth / tileSize);document.getElementById("Econtent").innerHTML="";
 numVisibleTilesY = Math.ceil(viewportHeight / tileSize); setTimeout(function(){
   stop=0;
   config.tilesize=currentValue2
 },3000)});

  </script>
  <div>"make9":[2,"null",4,3,0,0,[0,0,999999,999999],false,[[0,3],[0,-3]],0,0,0,".player",1]
  "class/tag":[speed,movement('','move','avoid','follow'),distance-to-player(blocks),randommove(1/0), collisionblockforplayer like collisionblocks,Enemy HP,[x,y,x2,y2],false,if 'move'=[[0,3],[0,-3]],hurtblocklikespike, scrip doesn't work if enemy is not visible,give score,custom sprites collision for attack def='player',anable custom sprite collision, hascollisionwithblocks(1/0/null)]</div>
<textarea name="" id="entitiesconfig" cols="30" rows="10" value="" onchange="updateSpriteConfigNpc()"></textarea>
<div onclick="togglemenu()">
 make entity Tiles (menu)
</div>
<div onclick="emptyproj()">
 makeEmptyProject (clearing Map,gravity,Blocks etc)
</div>
<div onclick="empty20()">
empty( tiles/ not map )
</div>
<div onclick="
newWidth = config.width*config.zoomadd;
newHeight = config.height*config.zoomadd;
cfigZ=1; config.zoomadd=1
vp.style.zoom = cfigZ*config.zoomadd;
 newWidth = config.width;
 newHeight = config.height;
vp.style.width = newWidth + 'px';
vp.style.height = newHeight + 'px';
">
 off zoom
</div>
<div onclick="gravity=0; ">
  top down mode
</div>
<div onclick="gravity=1; ">
  gravity
</div>
<script>
let fgh=0
function togglemenu(){
  document.querySelector('.entitymenu').classList.toggle('hide')
}
setTimeout(togglemenu,1000)
function toggh(){
  if(fgh==0){
    showlines=1
    fgh=1
  }else{
    showlines=0
    fgh=0
  }
}
function topdownbuttonsexmp(){
  document.querySelector('gui').innerHTML=`  <div class="btns">
      <div class="null added"></div>
      <div class="btn added" id="Up"></div>
      <div class="null added"></div>
      <div class="btn added" id="Left"></div>
      <div class="null added"></div>
      <div class="btn added" id="Right"></div>
      <div class="null added"></div>
      <div class="btn added" id="Down"></div>
      <div class="null added"></div>
  
    </div>

 	   	  <div class="jumpbtn added" id="Attack" style="transform: translate(0%,-100%)" onclick="attack2()"></div>
`
setTimeout(ukonczoneGUI,2000)
}
function platformergamebuttonexmp() {
  document.querySelector('gui').innerHTML = `  \n   <div class=\"btns\">\n    \n    \n    \n    \n    \n    \n    \n    \n    \n   </div>\n    <button id=\"Left\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 80, 200); left: 4.14062vw; top: 84.3793vh;\"></button><button id=\"Right\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 80, 200); left: 13.5156vw; top: 84.7743vh;\"></button><button id=\"Jump\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 120, 200); left: 85.625vw; top: 84.5833vh;\"></button><button id=\"Attack\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 120, 200); left: 85.3906vw; top: 65vh;\"></button>`
  setTimeout(ukonczoneGUI,2000)
}
function emptyproj(){
  playerY=200;
  
  playerX=200;
  TILES=[]
  tileMap=[[],[],[]]
  gravity=0
  document.querySelector('#Econtent').innerHTML=""
  document.querySelector('.f').innerHTML=""
  updateViewport()
}
  // Początkowe ustawienie wartości textarea na podstawie tileConfig
  document.getElementById('entitiesconfig').innerText=JSON.stringify(config.entities);

  // Funkcja do aktualizacji tileConfig na podstawie danych z textarea
  function updateSpriteConfigNpc() {
    try {
      // Parsowanie zawartości textarea do obiektu JSON
      stop=1
       config.entities =  JSON.parse(document.getElementById('entitiesconfig').value)

      // Aktualizacja tileConfig
      tileConfig = config.entities

alert(JSON.stringify(config.entities))
setTimeout(function(){
  stop=0
  alert(JSON.stringify(tileConfig))
},3000)
    } catch (error) {
      console.error('Błąd parsowania JSON:', error);
    }
  }

  // Uruchom funkcję updateSpriteConfigNpc co 5 sekund (5000 milisekund)
 // setInterval(updateSpriteConfigNpc, 5000);
</script>

</pre>
    </div>
    <button class="menu-toggle"></button>
  </div>
  <div class="hide menu2-content">
        <div class="teditor" onclick="TEditor()">
          editor
        </div>
<div id="cog">
  
      <div id="codeContainer"></div>
      <div id="scrollplus"></div>
    </div>
    <div class="rspeed2" onclick="STOP()">
      stop
    </div>
    <div class="rset" onclick="RESET()">
      reset
    </div>

    <div id="Alert">
      hey
    </div>
    <div id="devConsole"></div>
    
    <div class="varscontainer">
    <div class="vars"></div>
    </div>

    <div id="codeContainer2">
      <div id="output"></div>
      <div id="scrollplus"></div>
    </div>
    <div id="speed2SliderContainer">
      <div id="speed2Slider">
        <div id="sliderHandle"></div>
      </div>
      <div id="speed2Value">speed2: 1</div>
    </div>
    
    <div class="closebutton" onclick="visibility('.menu2-content')" style="position: absolute; bottom:10px; right:10px">x</div>
    
    <textarea name="" id="edytor" class="hide" cols="30" rows="10"></textarea>
  </div>
  
    <div class="hide menu0-content men1">




      <div class="closebutton" onclick="visibility('.men1-content')" style="position: absolute; bottom:10px; right:10px">x</div>
    </div>
<style>
  .hide{
    display: none;
    visibility: none;
  }
  .hide2{
    display: none
  }
  .a{
    background: #969696;
    color:#171717;
    z-index: 1;
    padding:5px;
  }
</style>
<script>
function visibility(element){
  document.querySelector(element).classList.toggle('hide')
}
function toggleVS() {
 var p =  document.querySelectorAll('.a')
 for(i=0; i<p.length; i++){
   p[i].classList.toggle('hide2')
 }
  
}
</script>






<!DOCTYPE html>
<html lang="en" onclick="document.documentElement.requestFullscreen()">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consout pre processor</title>
    <style>
        html {
            background: #000000;
            color: #F4F4F4;
        }

        * {
            margin: 0;
            user-select: none;
        }

        #devConsole {
            position: fixed;
            top: 10px;
            font-size: 10px;
            width: calc(50% + 5px);
            right: 10px;
            background-color: #070707;
            border: 1px solid #A2FAA3;
            padding: 10px;
        }

        #codeContainer {

        }
        #codeContainer2 {
          position: fixed;
          top: 60px;
          right: 10px;
          font-size: 12px;
          width: 30%;
          height: 50%;
          overflow: auto;
          background-color: #0D0D0D;
          border: 1px solid #A2FAA3;
          padding: 10px;
          transform: translateY(-50%, 0%);
        }
        #output {
            padding-left: 10px;
        }

        #scrollplus {
            width: 100vw;
            height: 30px;
        }

        .highlight {
            background-color: #4AD69178;
            padding: 1px;
            box-shadow: 0px 0px 5px #00FF81;
            border-radius: 4px;
        }
                #cog {
                  position: fixed;
                  width: 100vw;
                  height: 100vh;
                  overflow: hidden;
                  overflow: scroll;
                }
                .rspeed2{
                  position: absolute;
                  display: flex;
                  justify-content: center;
                  bottom:20px;
                  right:20px;
                  width: 40px;
                  height: 20px;
                  background: #0A0B09;
                  border: 1px solid #9AF38A;
                }
                .rset {
                  position: absolute;
                  display: flex;
                  justify-content: center;
                  bottom: 20px;
                  right: 70px;
                  width: 40px;
                  height: 20px;
                  background: #0A0B09;
                  border: 1px solid #9AF38A;
                  z-index: 12;
                }
                .teditor {
                  position: fixed;
                  display: flex;
                  z-index: 100;
                  justify-content: center;
                  bottom: 20px;
                  left: 20px;
                  width: 40px;
                  height: 20px;
                  background: #0A0B09;
                  border: 1px solid #9AF38A;
                }
#Alert{
  position: absolute;
  border: 1px solid #9AF38A;
  background: #101310;
  transform: translate(-50%,-50%);
  top:50vh;
  left:50vw;
  width:150px;
  display: none;
  align-items: center;
  justify-content: center;
  height:100px;
  z-index: 9;
}
.vars {
  
  word-wrap: break-word; /* Pozwól na podział długich słów */
  white-space: pre-wrap; /* Utrzymaj formatowanie tekstu i przenieś go pod spodem */
 
  
}
.varscontainer {
  position: absolute;
  border: 1px solid #9AF38A;
  background: #101310;
  top: 60px;
  right: calc(30% + 15px);
  width: 20%;
  align-items: center;
  justify-content: center;
  height: 50%;
  z-index: 1;
  
 overflow: hidden;
 overflow: scroll;
  
}
.hide{
  display: none
}
.tile-number {
  display: block;
  position: fixed;
  z-index: 9999999999999;
  background-color: #42445A70;
  width: 100px;
  padding: 10px;
  border: 1px solid black;
  color: black;
}

.visible {
  display: block;
}

    </style>
</head>
<body>
  <div id="container3">n</div>
  
  
<div id="tutor" onclick="document.getElementById('tutor').style.display='none'" class="notaproject"style="position:absolute; top:50vh; left:50vw; transform: translate(-50%,-50%); width: 80vw; height: 80vh;background: rgb(50,50,50);z-index: 9999;overflow:hidden;overflow:scroll; display:none">

<pre style="white-space: pre-wrap; color: white; font-family: 'Courier New', monospace;">

how entity code work

"make9":[2,"null",4,3,0,0,[0,0,999999,999999],false,[[0,3],[0,-3]],0,0,0,".player",1]
"class/tag":[speed,movement('','move','avoid','follow'),distance-to-player(blocks),randommove(1/0), collisionblockforplayer like collisionblocks,Enemy HP,[x,y,x2,y2],false,if 'move'=[[0,3],[0,-3]],hurtblocklikespike, scrip doesn't work if enemy is not visible,give score,custom sprites collision for attack def='player',anable custom sprite collision]

speed, movementType, distance, randomMovement, collision, initialHp, area, deletebool,arena,hurt,vi,score1,collisionobject=".player",detectanabled

 1. <span style="color: #00FF00;">**Zmienna (Line):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `l nazwa_zmiennej wartość`
 - <span style="color: #00FF00;">**Przykład:**</span> `l score 0`
 - <span style="color: #00FF00;">**Opis:**</span> Przypisanie wartości do zmiennej.
 
 2. <span style="color: #00FF00;">**Wypisywanie Tekstu (Output):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `ot tekst`
 - <span style="color: #00FF00;">**Przykład:**</span> `ot Hello, World!`
 - <span style="color: #00FF00;">**Opis:**</span> Wypisywanie tekstu w konsoli lub innym wyjściu.
 
 3. <span style="color: #00FF00;">**Sprawdzanie Kolizji (Collision):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `col obiekt1 obiekt2 linia`
 - <span style="color: #00FF00;">**Przykład:**</span> `col player enemy 42`
 - <span style="color: #00FF00;">**Opis:**</span> Sprawdzenie kolizji między dwoma obiektami. Jeśli kolizja zachodzi, wykonuje określone akcje na linii kodu `linia`.
 
 4. <span style="color: #00FF00;">**Konwersja Sprite'a do Bloku (Convert Sprite to Block):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `cnvrt sprite`
 - <span style="color: #00FF00;">**Przykład:**</span> `cnvrt player`
 - <span style="color: #00FF00;">**Opis:**</span> Konwersja określonego sprite'a na blok.
 
 5. <span style="color: #00FF00;">**Wypisanie na Lokalne Wyniki (Output to Local Results):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `out zmienna wartość`
 - <span style="color: #00FF00;">**Przykład:**</span> `out score 100`
 - <span style="color: #00FF00;">**Opis:**</span> Dodanie wartości do lokalnych wyników (możliwe efekty w grze).
 
 6. <span style="color: #00FF00;">**Ruch Sprite'a (Move Sprite):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `move sprite x y`
 - <span style="color: #00FF00;">**Przykład:**</span> `move player 5 0`
 - <span style="color: #00FF00;">**Opis:**</span> Przesunięcie sprite'a o określone wartości x i y.
 
 7. <span style="color: #00FF00;">**Skok Warunkowy (Jump If):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `jmp linia`
 - <span style="color: #00FF00;">**Przykład:**</span> `jmp 10`
 - <span style="color: #00FF00;">**Opis:**</span> Skok do określonej linii kodu.
 
 8. <span style="color: #00FF00;">**Grawitacja:**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `gravity 1` lub `gravity 0`
 - <span style="color: #00FF00;">**Przykład:**</span> `gravity 1`
 - <span style="color: #00FF00;">**Opis:**</span> Włączenie (1) lub wyłączenie (0) grawitacji.
 
 9. <span style="color: #00FF00;">**Budowanie Mapy Kafelków (Build Tile Map):**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `build x y typ`
 - <span style="color: #00FF00;">**Przykład:**</span> `build 3 4 3`
 - <span style="color: #00FF00;">**Opis:**</span> Dodanie kafelka o określonym typie na pozycji x, y na mapie.
 
 10. <span style="color: #00FF00;">**Warunek AND:**</span>
 - <span style="color: #00FF00;">**Składnia:**</span> `and zmienna wartość linia`
 - <span style="color: #00FF00;">**Przykład:**</span> `and health 0 20`
 - <span style="color: #00FF00;">**Opis:**</span> Sprawdzenie warunku logicznego AND i wykonanie skoku do określonej linii, jeśli warunek jest spełniony.

<hr>
11.
texture %texture[index] %to_texture[index]
np . texture 1 2
zmienia teksture danych elementów na teksture innego elementu
<hr>
12. 
press ID Line
sprawdza czy przycisk jest klikniety jeżeli tak to przeskakuje na linie
<hr>
13. 
tp class1 to class2
np. tp player sprites39 

movem i(num..) x,y
porusza blokiem z tileMap
w poruwnaniu do move moze poruszac bloki nie wczytane


</pre>
</div>

  
  
  
<script>


</script>
<script>
// ustalimy że w moim asemblerze zmienna Pin będzie pokazywała PINY kture będą właczone za każdym inicjowaniem tej zmiennej 
// będzie słuzyła do tego komenda PIN maksymalnie będzie 32 pinów o to przykład komendy
// pin-get 2 1
// pin-get %pin/max32 %low(0)/hight(1)
// kiedy zastosuje się hight ponownie na pinie to zostanie ten pin xorem usunięty 
let speed2 = config.Hz; // Hz
var g=config.noasm// start(0),norun(1);
    let code =config.code;
    if(config.debugmode==1){
      g=1
    }
/*
2: l x 0
3: l y 5
4: add x 1
5: show x
6: and x y 8
7: jmp 4
8: ot HelloWorld!
9: jmp 1




1:
2: l x 0
3: l y 4
4: add x 1
5: and x y 9
6: and x z 12
7: and x a 15
8: jmp 4
9: ot Hello
10: l z 8
11: jmp 4
12: ot World
13: l a 12
14: jmp 4
15: ot CNASM
16: l o 24
17: add x 1
18: and x o 20
19: jmp 17
20: ot Program
*/

function checkclassCollision(class1, class2) {
  const elements1 = document.getElementsByClassName(class1);
  const elements2 = document.getElementsByClassName(class2);

  for (let i = 0; i < elements1.length; i++) {
    for (let j = 0; j < elements2.length; j++) {
      const rect1 = elements1[i].getBoundingClientRect();
      const rect2 = elements2[j].getBoundingClientRect();
      AX=parseInt(elements1[i].style.left)
      AY=parseInt(elements1[i].style.top)
      CX=parseInt(elements2[j].style.left)
      CY=parseInt(elements2[j].style.top)
let distanceToPlayer = Math.sqrt(((CX - AX) / tileSize) ** 2 + ((CY - AY) / tileSize) ** 2);

      if (
        distanceToPlayer<=1
      ) {
        return 1; // Zwraca 1 w przypadku kolizji
      }
    }
  }

  return undefined; // Brak kolizji
}



function textToBinary(text) {
  return text.split('').map(function(char) {
    return char.charCodeAt(0).toString(2).padStart(8, '0');
  }).join(' ');
}
function numberToBinary(number) {
  return number.toString(2);
}


function TEditor(){
document.getElementById('edytor').classList.toggle('hide')
}
// Dodaj funkcję do parsowania wartości (liczby lub zmiennej)
function parseValue(value) {
  if (!isNaN(value)) {
    // Jeśli wartość jest liczbą, zwróć ją jako liczbę
    return parseFloat(value);
  } else {
    // Jeśli wartość nie jest liczbą, sprawdź, czy jest zmienną
    if (V.includes(value)) {
      // Jeśli jest zmienną, zwróć wartość zmiennej
      return Vables[value];
    } else {
      // Jeśli nie jest liczbą ani zmienną, zwróć 0 (lub odpowiednią wartość domyślną)
      return 0;
    }
  }
}
function STOP(){
  const outputDiv = document.getElementById("codeContainer");
  outputDiv.innerHTML = ""
  document.querySelector('.vars').innerHTML = ""
  V = []
  g=1
  
}
function hideelements(element){
  if(document.querySelector(element)){
    let elements = document.querySelectorAll(element)
  for (var i = 0; i < elements.length; i++) {
elements[i].style.display="none"
elements[i].style.touchaction="none"
  }}
}
function showelements(element){
  if(document.querySelector(element)){
    let elements = document.querySelectorAll(element)
  for (var i = 0; i < elements.length; i++) {
elements[i].style.visibility="visible"
elements[i].style.touchaction="auto"
  }}
}
var V=[]
function RESET(){
  
  Vables={}
  localout=[]
    g = 1
    currentLine = 0;
    curline=0
  alert2("machine communication please stand by")
  const outputDiv = document.getElementById("codeContainer");
  outputDiv.innerHTML=""
  document.querySelector('.vars').innerHTML=""
  V=[]
    setTimeout(function(){
      g = 0
    interpretCode()
  
    },2500)
    
}
function alert2(text){
  let xspeed2=speed2
  document.getElementById('Alert').style.display="flex"
  document.getElementById('Alert').innerText=text
  speed2=2
  setTimeout(function(){
    document.getElementById('Alert').style.display="none"
    speed2=xspeed2
  },500)
}

var touchX, touchY;
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}

function setTouchPosition(event) {
  event.preventDefault()
    if (event.touches && event.touches.length > 0) {
        // Jeżeli używasz ontouchmove lub innych zdarzeń dotknięcia
        touchX = event.touches[0].pageX;
        touchY = event.touches[0].pageY;
    } else if (event.pageX !== undefined && event.pageY !== undefined) {
        // Jeżeli używasz onclick
        touchX = event.pageX;
        touchY = event.pageY;
        
    }
}

// Przykład użycia:
document.querySelector('*').addEventListener('touchstart', setTouchPosition);

function trzymamId(klasaElementu) {
  
    const element = document.getElementById(klasaElementu);
//(element)
    if(element){

        
            const rect = element.getBoundingClientRect();
            if (
                touchX >= rect.left &&
                touchX <= rect.right &&
                touchY >= rect.top &&
                touchY <= rect.bottom
            ) {
              //console.log(touchX,touchY)
                return 1;
                
            }
        
}
}



var localout=[]
    let Vables = {};
    
    let nospeed2lines = false;
let candocmd=1
let curline=0
let currentLine = 0;
let candothath=0
var defy=0
let jmptimes=0
    function interpretCode() {
      
        const lines = code.split('\n');
        const devConsole = document.getElementById("devConsole");
        const outputDiv = document.getElementById("output");
        const codeContainer = document.getElementById("codeContainer");

         function processLine(line, lineNumber) {
           //console.log("Line:", line ,' Num:',lineNumber); // Add this line to check the value of 'line'

          if(g==0&&isgamepaused==0){
            if (line.trim() !== "") {
                
                const [numLine, restOfLine] = line.split(':');
                const trimmedLine = restOfLine.trim();
                displayResult2(numLine+",");

                if (trimmedLine.startsWith("l")) {
                    const match = trimmedLine.match(/l\s+(\w+)\s+(.+)/);
                    if (match) {
                      const [_, name, value] = match;
                      // Evaluate JavaScript expression for Vable assignment
                      try {
                        Vables[name] = eval(value);
                        if (!V.includes(name)) {
                          V.push(name);
                        }
                      } catch (error) {
                        console.error(`Error in line ${lineNumber}: ${error}`);
                      }
                    }
                }
else if (trimmedLine.startsWith("hide")) {
  const match = trimmedLine.match(/hide\s+(.+)/);
  if (match) {
    const [_, element] = match;

    hideelements(element)
    console.log(element)
  }
}else if (trimmedLine.startsWith("movem")) {
  const match = trimmedLine.match(/movem\s+(\d+)\s+(\d+)\s+(\d+)/);
  
  if (match) {
    const [_, text, x, y] = match;
    

    console.log(parseInt(x), x);

    movemap(x,y,text);



  }
}
else if (trimmedLine.startsWith("show")) {
  const match = trimmedLine.match(/hide\s+(.+)/);
  if (match) {
    const [_, element] = match;

    showelements(element)
    console.log(element)
  }
}
if (trimmedLine.startsWith("eval")) {
                  const match = trimmedLine.match(/eval\s+(.+)/);
                  if (match) {
                    const [_, evaluate] = match;
eval(evaluate)
                  }
                }else if (trimmedLine.startsWith("ot")) {
                  const match = trimmedLine.match(/ot\s+(\w+)/);
                  
                  if (match) {
                    const [_, text] = match;
                  //  alert2(text)
                    displayResult3(text)
                  }
                } else if (trimmedLine.startsWith("col")) {
                  const match = trimmedLine.match(/col\s+(\w+)\s+(\w+)\s+(\-?\+?\d+)/);
               // alert("match")
                  if (match) {
                    const [_, col1,col2,targetLine] = match;
                    console.log(col1,col2)
if(checkclassCollision(col1,col2)){
const jumpAmount = parseInt(targetLine);
  if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
    const newLineNumber = currentLine + jumpAmount;
    // alert(newLineNumber)
    //    alert("")
    updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
    highlightLine(lineNumber);
    return newLineNumber >= 0 ? newLineNumber : 0;
  } else {
    const newLineNumber = parseInt(targetLine) - 1;
    updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
    highlightLine(lineNumber);
    return newLineNumber >= 0 ? newLineNumber : 0;
  }
}
                  }
                }else if (trimmedLine.startsWith("cnvrt")) {
                  const match = trimmedLine.match(/cnvrt\s+(\w+)/);
                
                  if (match) {
                    const [_, text] = match;
                   //  alert(text)
                    convertspritetoblock(text)
                  }
                }else if (trimmedLine.startsWith("rm")) {
  const match = trimmedLine.match(/rm\s+(.+)/);

  if (match) {
    const [_, targetSelector] = match;
    
    const elementsToRemove = document.querySelectorAll(targetSelector);

    elementsToRemove.forEach(element => {
      element.remove();
      
    });
  }
}
else if (trimmedLine.startsWith("out")) {
                  const match = trimmedLine.match(/ot\s+(\w+)\s+(\d+)/);
                
                  if (match) {
                    const [_, text, value] = match;
                    
                    addLocal(text,value)

                  }
                }else if (trimmedLine.startsWith("move")) {
  const match = trimmedLine.match(/move\s+([^\s]+)\s+(.+)\s+(.+)/);
  
  if (match) {
    const [_, text, x, y] = match;

    console.log(parseInt(x), x);
    spritetomove = text;
    
      movesprite(x, y);
    
      
    
  }
}


else if (trimmedLine.startsWith("make")) {
  const match = trimmedLine.match(/make\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)/);

  if (match) {
    const [_, classlist2, x, y] = match;

    if (isNaN(x) || isNaN(y)) {
      // Jeśli x lub y nie są liczbami, sprawdź, czy istnieje zmienna w obiekcie Vables
      const parsedX = Vables[x] !== undefined ? Vables[x] : parseFloat(x);
      const parsedY = Vables[y] !== undefined ? Vables[y] : parseFloat(y);

      // Sprawdź, czy parsedX i parsedY są liczbami
      if (!isNaN(parsedX) && !isNaN(parsedY)) {
        let element = document.createElement('div');
        element.classList.add(classlist2);
        element.className = `make${TILES[classlist2][0]} tile1 sprite${TILES[classlist2][1]} SPRITE`;
        element.style.backgroundImage = `url('${TILES[classlist2][2]}');`;
        element.style.left = parsedX * tileSize + "px";
        element.style.top = parsedY * tileSize + "px";
        element.style.width="30px"
        element.style.height="30px"
        document.getElementById('Scontent').appendChild(element);
        element.style.backgroundImage = `url("${TILES[parseInt(classlist2)][2]}")`;
      } else {
        alert("Nieprawidłowe wartości x lub y w komendzie 'make'");
      }
    } else {
      let element = document.createElement('div');
      element.classList.add(classlist2);
      element.className = `alltiles${TILES[classlist2][0]} tile1 sprite${TILES[classlist2][1]} SPRITE`;
      element.style.backgroundImage = `url('${TILES[classlist2][2]}');`;
      element.style.left = parseFloat(x) * tileSize + "px";
      element.style.top = parseFloat(y) * tileSize + "px";
      document.getElementById('Econtent').appendChild(element);
      element.style.backgroundImage = `url("${TILES[parseInt(classlist2)][2]}")`;
    }
  }
}


else if (trimmedLine.startsWith("tp")) {
                  const match = trimmedLine.match(/tp\s+(\w+)\s+(\w+)/);
                
                  if (match) {
                    const [_, class1, class2] = match;
                    teleportSprite(class1,class2)
                
                  }
                } else if (trimmedLine.startsWith("jmp")) {
    const match = trimmedLine.match(/jmp\s+(\-?\+?\d+)/);
    if (match) {
        const [_, targetLine] = match;
        const jumpAmount = parseInt(targetLine);
        if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
            const newLineNumber = currentLine + jumpAmount;
          //  alert(newLineNumber)
        //    alert("")
            updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
            highlightLine(lineNumber);
            return newLineNumber >= 0 ? newLineNumber : 0;
        } else {
            const newLineNumber = parseInt(targetLine) - 1;
            updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
            highlightLine(lineNumber);
            return newLineNumber >= 0 ? newLineNumber : 0;
        }
    }
}
else if (trimmedLine.startsWith("jmpt")) {
                  const match = trimmedLine.match(/jmpt\s+(\d+)\s+(\d+)/);
                  alert("")
                  if (match) {
                    
                    const [_, targetLine,times] = match;
                    if(jmptimes<times){
                      jmptimes++;
                    updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
                    highlightLine(lineNumber);
                
                    return parseInt(targetLine) - 1;
                  }else{
                   //jmptimes=0
                  }
                    
                  }
                }
else if (trimmedLine.startsWith("press")) {
    const match = trimmedLine.match(/press\s+(.+)\s+(\-?\+?\d+)/);
    if (match) {
      
        const [_, idToCheck, targetLine] = match;
        console.log(idToCheck)
        if (trzymamId(idToCheck)) { // Załóż, że funkcja 
        console.log("trzymam")
        const jumpAmount = parseInt(targetLine);
        if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
          const newLineNumber = currentLine + jumpAmount;
//alert(newLineNumber)
          //    alert("")
          updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
          highlightLine(lineNumber);
          return newLineNumber >= 0 ? newLineNumber : 0;
        } else {
          const newLineNumber = parseInt(targetLine) - 1;
          updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
          highlightLine(lineNumber);
          
          return newLineNumber >= 0 ? newLineNumber : 0;
        }
        }
    }
}

else if (trimmedLine.startsWith("gravity")) {
                  const match = trimmedLine.match(/gravity\s+(\d+)/);
                  if (match) {
                    const [_, targetLine] = match;
                    if(targetLine==1){
                      gravity=1
                    }else{
                      gravity=0
                    }
                  }
                }
else if (trimmedLine.startsWith("build")) {
  const match = trimmedLine.match(/build\s+([\d\w]+)\s+([\d\w]+)\s+([\d\w]+)/);
  if (match) {
    const [_, x, y, t] = match;
    const parsedX = parseValue(x);
    const parsedY = parseValue(y);
    const parsedT = parseValue(t);
    tileMap[dimension].push([parsedX, parsedY, parsedT]);
    updateViewport();
  }
}



else if (trimmedLine.startsWith("and")) {
  const match = trimmedLine.match(/and\s+(\w+)\s+(\w+)\s+(\-?\+?\d+)/);
  if (match) {
    const [_, Vable, value, targetLine] = match;
    console.log(Vable,value)
    if (evaluateConditionAND(Vable,value)) {
      const jumpAmount = parseInt(targetLine);
      if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
        const newLineNumber = currentLine + jumpAmount;
        //  alert(newLineNumber)
        //    alert("")
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      } else {
        const newLineNumber = parseInt(targetLine) - 1;
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      }
    }
  }
}
else if (trimmedLine.startsWith("nand")) {
  const match = trimmedLine.match(/nand\s+(\w+)\s+(\w+)\s+(\-?\+?\d+)/);
  if (match) {
    const [_, Vable, value, targetLine] = match;
    console.log(Vable, value)
    if (evaluateConditionNAND(Vable, value)) {
      const jumpAmount = parseInt(targetLine);
      if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
        const newLineNumber = currentLine + jumpAmount;
        //  alert(newLineNumber)
        //    alert("")
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      } else {
        const newLineNumber = parseInt(targetLine) - 1;
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      }
    }
  }
}
else if (trimmedLine.startsWith("not")) {
  const match = trimmedLine.match(/not\s+(\w+)\s+(\-?\+?\d+)/);
  if (match) {
    const [_, Vable, targetLine] = match;
    
    if (evaluateConditionNOT(Vable)) {
      const jumpAmount = parseInt(targetLine);
      if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
        const newLineNumber = currentLine + jumpAmount;
        //  alert(newLineNumber)
        //    alert("")
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      } else {
        const newLineNumber = parseInt(targetLine) - 1;
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      }
    }
  }
}
else if (trimmedLine.startsWith("jif")) {
                    const match = trimmedLine.match(/jif\s+(\w+)\s+(\W+)\s+(\d+)\s+(\d+)/);
                    if (match) {
                        const [_, Vable, operation, value, targetLine] = match;
                        if (evaluateCondition(Vable, operation, parseInt(value))) {
                             updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
                            highlightLine(lineNumber);
                            
                            return parseInt(targetLine);
                        }
                    }
                }
else if (trimmedLine.startsWith("ppos")) {
  const match = trimmedLine.match(/ppos\s+(.+)\s+(.+)\s+(\d+)/);

  
  if(candocmd){
  if (match) {
    var [_, x, y, add] = match;
    x=parseFloat(x)
    y=parseFloat(y)
add=parseFloat(add)
   // alert2(x+'...'+y)
//    candocmd=0
    if(add){
    movePlayer((x),(y))
    }else{
    setPlayer((x),(y))
    } 
    updateViewport()
  }}
//  candocmd=1
    
    
  
}
else if (trimmedLine.startsWith("chblock")) {
  const match = trimmedLine.match(/chblock\s+(\d+)\s+(\d+)\s+(\w+)\s+(\d+)/);
  // chblock x,y,type,line
  if (match) {
    const [_, x, y, type, line] = match;
    
  }
}else if (trimmedLine.startsWith("add")) {
                    const match = trimmedLine.match(/add\s+(\w+)\s+(\d+)/);
                    if (match) {
                        const [_, Vable, value] = match;
                        if (Vables[Vable] !== undefined) {
                            Vables[Vable] += parseInt(value);
                        }
                    }
                } else if (trimmedLine.startsWith("sub")) {
                    const match = trimmedLine.match(/sub\s+(\w+)\s+(\d+)/);
                    if (match) {
                        const [_, Vable, value] = match;
                        if (Vables[Vable] !== undefined) {
                            Vables[Vable] -= parseInt(value);
                        }
                    }
                } else if (trimmedLine.startsWith("show")) {
                    const match = trimmedLine.match(/show\s+(\w+)/);
                    if (match) {
                        const [_, Vable] = match;
                        displayResult("Output :", Vable);
                    }
                }else if (trimmedLine.startsWith("texture")) {
                  const match = trimmedLine.match(/texture\s+(\w+)\s+(\w+)/);
                  if (match) {
                    const [_, input,texture] = match;
                    TILES[input][2]=TILES[texture][2]
                  }
                }
                highlightLine(lineNumber);
              /*  if (!nospeed2lines) {
                  if(speed2<100){
                     sleep(1000 / speed2);
                  }else if(speed2<150) {
                    
                    if(zonz==0){
                     sleep(0); 
                    zonz=1
                    }else{
                    zonz-=1
                    }
                  } else if(speed2<240){
                    if (zonz == 0) {
                       sleep(0);
                      zonz = 6
                    } else {
                      zonz -= 1
                    }
                  }
                  else if (speed2 < 260) {
                    if (zonz == 0) {
                       sleep(0);
                      zonz = 12
                    } else {
                      zonz -= 1
                    }
                  }else if (speed2 < 400) {
                    if (zonz == 0) {
                       sleep(0);
                      zonz = 19
                    } else {
                      zonz -= 1
                    }
                  }
                }*/
                 updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
                const outputDiv = document.getElementById("codeContainer");
                if (codeContainer.children.length > 30) {
                  codeContainer.removeChild(codeContainer.firstChild);
                }
            
            addVar()
            }
            return null;
        }
        }
        
let zonz = 0;


function interpret() {
if(isgamepaused==0){
  if (config.Hz <1009 && currentLine < lines.length) {
    const startTime = performance.now();

    function processNextLine() {
      
  if (g === 0 ) {
    const result = processLine(lines[currentLine], currentLine + 1);

    if (result !== null) {
      if (result !== null) {
        currentLine = result;
      }else {
        console.warn("Trying to jump to an out-of-bounds line.:", result);
      }
     
    } else {
      currentLine++;
    }

    
    if(config.Hz >1 ){
      if(candothath==0){
        candothath=1
        setTimeout(() => {
          requestAnimationFrame(processNextLine);
        }, frameTime);
    setTimeout(() => {
      
      candothath=0
      setTimeout(() => {
        requestAnimationFrame(processNextLine);
      }, frameTime);
   
    }, config.Hz);
    
      }
    }else{
      setTimeout(() => {
        requestAnimationFrame(processNextLine);
      }, frameTime);
      
      defy++;
      if(defy>config.boosttimeout){
        defy=0
      }
    }
  }
  
}


    processNextLine()
    function processWithTimeout(count, delay) {
    if (count > 0) {
        setTimeout(function() {
            processNextLine();
            processWithTimeout(count - 1, delay);
        }, delay);
    }
}

// Ustal ilość i opóźnienie na podstawie config.requests
const requestCount = config.requests || 1;
const delay = 50;

// Uruchom funkcję z timeoutem
processWithTimeout(requestCount, delay);

  }
}}


         function updateDevConsole(lineNumber, currentspeed2, VableCount) {
            devConsole.innerHTML = `Obecna linia: ${lineNumber}, Prędkość: ${currentspeed2} Hz, Liczba zmiennych: ${VableCount}`;
        }
        




function addVar() {
  document.querySelector('.vars').innerHTML = "";

  for (let i = 0; i < V.length; i++) {
    document.querySelector('.varscontainer').scrollBy(0,200)
    document.querySelector('.vars').innerHTML += V[i] + "=" + Vables[V[i]] + " x" + numberToBinary(Vables[V[i]]) + "\n";
    
            
  }

  // Aktualizuj wartość sumatora XOR
  let xorResult = 0;
  for (let i = 0; i < V.length; i++) {
    xorResult ^= Vables[V[i]];
  }

  // Sprawdź, czy sumator XOR jest już w localout
  let xorIndex = localout.findIndex(item => item[0] === "XOR");

  if (xorIndex !== -1) {
    // Jeśli sumator XOR już istnieje, aktualizuj jego wartość
    localout[xorIndex][1] = xorResult;
  } else {
    // Jeśli sumator XOR nie istnieje, dodaj go do localout
    localout.push(["XOR", xorResult]);
  }

  // Wyświetl localout w elemencie z klasą 'vars'
  for (let i = 0; i < localout.length; i++) {
    document.querySelector('.vars').innerHTML +='<br>' + localout[i][0] + "=" + localout[i][1] + " x" + numberToBinary(localout[i][1]) + "\n";
  }
}







        function highlightLine(lineNumber) {
            outputDiv.innerHTML = lines
                .map((line, index) => `<div class="${index + 1 === lineNumber ? 'highlight' : ''}">${line}</div>`)
                .join('');
        }

        interpret();

    }

    function evaluateCondition(Vable, operation, value) {
     // console.log(operation)
      operation=parseFloat(operation)
        if (Vables[Vable] !== undefined) {
            if (operation === ">") {
                return Vables[Vable] > value;
            } else if (operation === "<") {
                return Vables[Vable] < value;
            } else if (operation === "==") {
                return Vables[Vable] === value;
              //  console.log('done1')
            }
        }
        return false;
    }

function evaluateConditionAND(Vable, value) {
  
 
  if (Vables[Vable] !== undefined) {
    if (Vables[Vable]==Vables[value]) {
      console.log('done1')
      return Vables[Vable]==Vables[value];
      
    }
  }
  return false;
}
function evaluateConditionNOT(Vable) {


  if (Vables[Vable] !== undefined) {
    if (Vables[Vable] <1) {
      console.log('done1')
      return Vables[Vable] <1;
    }
  }
  return false;
}
function evaluateConditionNAND(Vable, value) {
  
 
  if (Vables[Vable] !== undefined) {
    if (Vables[Vable]!==Vables[value]) {
      console.log('done1')
      return Vables[Vable]!==Vables[value];
      
    }
  }
  return false;
}


    function displayResult(t, Vable) {
        const outputDiv = document.getElementById("codeContainer");
        document.getElementById("cog").scrollBy(0, 2000);
        outputDiv.innerHTML += `<div>  <d style="color: #4AD6BB;" >${t}</d>  <d style="color:yellow;" >${Vable}</d>:   <d style="color: #209195;" >${Vables[Vable]}</d> <d style="color:#FFF" > ${numberToBinary(Vables[Vable])} </d></div><br>`;
    }
function displayResult3(t, Vable) {
        const outputDiv = document.getElementById("codeContainer");
        document.getElementById("cog").scrollBy(0, 2000);
        outputDiv.innerHTML += `<div>  <d style="color: #F1F1F;" >${t}</d></div>`;
    }

    function displayResult2(t) {
        const codeContainer = document.getElementById("codeContainer");
        const cd = document.getElementById("cog");
 //       codeContainer.innerHTML += `<d style="color: #D64A4A;">${t}</d>`;
        cd.scrollBy(0,2000)
                if (codeContainer.children.length > 40) {
                  codeContainer.removeChild(codeContainer.firstChild);
                } 
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Uruchom interpreter
    setTimeout(interpretCode,1000)
</script>


<style>


#edytor {
  
background: #161916;
border: 1px solid #9DFF9A;
width:90%;
height: 90%;
position: absolute;
transform:translate(-50%,-50%);
top:50vh;
left:50vw;
outline:none;
color:#9DFF9A;
z-index: 11;
}


</style>
<textarea name="" id="edytor" class="hide" cols="30" rows="10"></textarea>
<script>

setTimeout(function(){
  document.getElementById('edytor').textContent=code
  update1()
},200)

function update1(){
  code=document.getElementById('edytor').value
//  console.log(code)
  setTimeout(update1,1000)
}
</script>





</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assembler Interpreter</title>
    <style>
        html {
            background: #000000;
            color: #F4F4F4;
            font-family: Arial, sans-serif;
        }

        * {
            margin: 0;
            box-sizing: border-box;
        }

        #speed2SliderContainer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #speed2Slider {
            width: 200px;
            height: 10px;
            background-color: #1F1F1F;
            border-radius: 5px;
            margin-bottom: 10px;
            
            position: relative;
        }

        #sliderHandle {
            width: 20px;
            height: 20px;
            background-color: #A2FAA3;
            border-radius: 50%;
            
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        #speed2Value {
            font-size: 14px;
            color: #A2FAA3;
        }
    
    </style>
</head>
<body>



<script>
    
    let itisdragging = false;
    let maxSlide = 300; // Default max slide value

    // Handle speed2 slider interaction
    const speed2Slider = document.getElementById("speed2Slider");
    const sliderHandle = document.getElementById("sliderHandle");
    const speed2Value = document.getElementById("speed2Value");

    sliderHandle.addEventListener("mousedown", startSlide);
    sliderHandle.addEventListener("mouseup", stopSlide);

    sliderHandle.addEventListener("touchstart", startSlideTouch);
    sliderHandle.addEventListener("touchend", stopSlideTouch);

    function startSlide(e) {
        e.preventDefault();
        itisdragging = true;
        window.addEventListener("mousemove", slide);
        window.addEventListener("mouseup", stopSlide);
    }

    function stopSlide() {
        itisdragging = false;
        window.removeEventListener("mousemove", slide);
        window.removeEventListener("mouseup", stopSlide);
    }

    function slide(e) {
        if (itisdragging) {
            const sliderWidth = speed2Slider.offsetWidth;
            const mouseX = e.clientX - speed2Slider.getBoundingClientRect().left;
            const percentage = Math.max(0, Math.min(0, mouseX / sliderWidth));
            speed2 = 1 + Math.round(maxSlide * percentage);
            updateSlider();
        }
    }

    function startSlideTouch(e) {
      
        e.preventDefault();
        itisdragging = true;
        window.addEventListener("touchmove", slideTouch);
    }

    function stopSlideTouch() {
        itisdragging = false;
        window.removeEventListener("touchmove", slideTouch);
    }

    function slideTouch(e) {
        if (itisdragging) {
          speed2=1
            const sliderWidth = speed2Slider.offsetWidth;
            const touchX = e.touches[0].clientX - speed2Slider.getBoundingClientRect().left;
            const percentage = Math.max(0, Math.min(1, touchX / sliderWidth));
            speed2 = 1 + Math.round(maxSlide * percentage);
            updateSlider();
        }
    }

    function updateSlider() {
      
        const handlePosition = (speed2 - 0) / maxSlide * (speed2Slider.offsetWidth - sliderHandle.offsetWidth);
        sliderHandle.style.left = `${handlePosition}px`;
        speed2Value.textContent = `speed2: ${speed2}`;
    }

    // Initial setup;
    updateSlider();
</script>

</body>
</html>


<!-- 
zrub interpreter matrycy 
9bit czyli
clk(1/3) 1 2 4 8   1 2 4 8
jezeli 4bit = 16
to za drugim pulsem clk 
4bit będzie równe 32 ponieważ= 16+16
a za 3 = 48



-->
<!-- 
zrub ustawienia deweloperskie 
- pokaż zmienne
- kod binarny 
- kod w trybie binarnym
- tutorial
- zapisz
- wczytaj
- 
-->





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        .przesuwalny {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
        }

        #modal-container {
            position: fixed;
            
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999999;
            display: none;
        }

        #modal-content {
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
    <title>Edytor Przycisków</title>
</head>
<body>
    <button  style="position: fixed; top:20px; left:0px;background-color: #4CAF50; 
    color: white;
    padding: 10px 20px;
    text-align: center;
    text-decoration: none;
    
    font-size: 16px;
    margin: 4px 2px;"
    class="notaproject d"
    onclick="pokazModal()">opcje zaw</button>

    <button style="position: absolute; top:70px; left:0px;background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    text-align: center;
    text-decoration: none;
    
    font-size: 16px;
    margin: 4px 2px;" class="notaproject d" onclick="usunElementy()">Usun wsz</button>

    <div id="modal-container">
        <div id="modal-content">
            <input type="text" id="klasaInput" placeholder="Wprowadź klasę dla nowego przycisku">
            <br>
            <input type="text" id="styleInput" placeholder="Wprowadź style CSS dla nowego przycisku" value="width:50px;height:50px;background:rgba(80,80,200,1)">
            <br>
            <input type="text" id="tekstInput" placeholder="Wprowadź tekst dla nowego przycisku">
            <br>
            <input type="text" id="IdInput" placeholder="Left,Right,Up,Down">
            <br>
            <button onclick="dodajPrzyciskZModalu()">Dodaj przycisk</button>
            <button onclick="ukonczoneGUI()">Zakończ gui</button>
            <button onclick="dodajToProject()">dodaj  do project </button>
            <button onclick="schowajModal()">Anuluj</button>
        </div>
    </div>

    <script>
    function dodajCiemnote(){
  config.DarknessEffect=1
  setTimeout(function() {
    if (config.DarknessEffect==1) {
      let vp = document.getElementById("viewport")
      let el = document.createElement('div')
      el.style = `width:${vp.style.width};height:${vp.style.height};`
      el.className = 'dark effects added'
      document.querySelector('#project').appendChild(el)
    } else {
      let y = document.querySelectorAll('.effects')
      for (var i = 0; i < y.length; i++) {
        
          y[i].remove()
        
      }
    }
  }, 1000)

}
        function pokazModal() {
            const modal = document.getElementById('modal-container');
            modal.style.display = 'flex';
        }

        function schowajModal() {
            const modal = document.getElementById('modal-container');
            modal.style.display = 'none';
        }
function dodajToProject(){
  
            const klasa = document.getElementById('klasaInput').value;
            const style = document.getElementById('styleInput').value;
            const tekstPrzycisku = document.getElementById('tekstInput').value;
const idPrzycisku = document.getElementById('IdInput').value;
            const nowyPrzycisk = document.createElement('div');

            if (klasa) {
                nowyPrzycisk.className = klasa;
            }
nowyPrzycisk.id = idPrzycisku;
            if (style) {
                nowyPrzycisk.style.cssText = style;
            }

            nowyPrzycisk.textContent = tekstPrzycisku || '';
            nowyPrzycisk.className += 'PROJECT przesuwalny added';
            dodajObslugePrzesuwania(nowyPrzycisk);
            dodajObslugeUsuwanie(nowyPrzycisk);
            document.querySelector('#project2').appendChild(nowyPrzycisk);

            schowajModal();
            
config.guiHTML2=document.querySelector('#project2').innerHTML
alert(config.guiHTML2)
if (document.getElementById('Left')) {
  document.getElementById('Left').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    leftButtonDown = 1;
  });

  document.getElementById('Left').addEventListener('touchend', function() {
    leftButtonDown = 0;
  });
}

if (document.getElementById('Right')) {
  document.getElementById('Right').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    rightButtonDown = 1;
  });

  document.getElementById('Right').addEventListener('touchend', function() {
    rightButtonDown = 0;
  });
}

if (document.getElementById('Up')) {
  document.getElementById('Up').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    upButtonDown = 1;
  });

  document.getElementById('Up').addEventListener('touchend', function() {
    upButtonDown = 0;
  });
}

if (document.getElementById('Down')) {
  document.getElementById('Down').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    downButtonDown = 1;
  });

  document.getElementById('Down').addEventListener('touchend', function() {
    downButtonDown = 0;
  });
}

var jumpElement = document.getElementById('Jump');

if (jumpElement) {
  jumpElement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    jump2();
  });
}

var atackelement = document.getElementById('Attack');

if (atackelement) {
  atackelement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    attack2();
  });
}
}
        function dodajPrzyciskZModalu() {
            const klasa = document.getElementById('klasaInput').value;
            const style = document.getElementById('styleInput').value;
            const tekstPrzycisku = document.getElementById('tekstInput').value;
const idPrzycisku = document.getElementById('IdInput').value;
            const nowyPrzycisk = document.createElement('div');

            if (klasa) {
                nowyPrzycisk.className = klasa;
            }
nowyPrzycisk.id = idPrzycisku;
            if (style) {
                nowyPrzycisk.style.cssText = style;
            }

            nowyPrzycisk.textContent = tekstPrzycisku || '';
            nowyPrzycisk.className += ' przesuwalny added';
            dodajObslugePrzesuwania(nowyPrzycisk);
            dodajObslugeUsuwanie(nowyPrzycisk);
            document.querySelector('gui').appendChild(nowyPrzycisk);

            schowajModal();
            

if (document.getElementById('Left')) {
  document.getElementById('Left').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    leftButtonDown = 1;
  });

  document.getElementById('Left').addEventListener('touchend', function() {
    leftButtonDown = 0;
  });
}

if (document.getElementById('Right')) {
  document.getElementById('Right').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    rightButtonDown = 1;
  });

  document.getElementById('Right').addEventListener('touchend', function() {
    rightButtonDown = 0;
  });
}

if (document.getElementById('Up')) {
  document.getElementById('Up').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    upButtonDown = 1;
  });

  document.getElementById('Up').addEventListener('touchend', function() {
    upButtonDown = 0;
  });
}

if (document.getElementById('Down')) {
  document.getElementById('Down').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    downButtonDown = 1;
  });

  document.getElementById('Down').addEventListener('touchend', function() {
    downButtonDown = 0;
  });
}

var jumpElement = document.getElementById('Jump');

if (jumpElement) {
  jumpElement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    jump2();
  });
}

var atackelement = document.getElementById('Attack');

if (atackelement) {
  atackelement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    attack2();
  });
}
        }

        function dodajObslugePrzesuwania(element) {
            let startX, startY, offsetX, offsetY;

            function rozpocznijPrzesuniecie(e) {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    offsetX = element.getBoundingClientRect().left;
                    offsetY = element.getBoundingClientRect().top;
                    document.addEventListener('touchmove', przesun);
                    document.addEventListener('touchend', zakonczPrzesuniecie);
                }
            }

            function przesun(e) {
    if (e.touches.length === 1) {
        const touch = e.touches[0];

        // Pobierz szerokość i wysokość widoku (viewport) w vw i vh
        const viewportWidth = window.innerWidth * 0.01;
        const viewportHeight = window.innerHeight * 0.01;

        // Oblicz nowe wartości left i top w vw i vh
        const leftVw = (touch.clientX - startX + offsetX) / viewportWidth + 'vw';
        const topVh = (touch.clientY - startY + offsetY) / viewportHeight + 'vh';

        // Ustaw nowe wartości dla left i top
        element.style.left = leftVw;
        element.style.top = topVh;
    }
}


            function zakonczPrzesuniecie() {
                document.removeEventListener('touchmove', przesun);
                document.removeEventListener('touchend', zakonczPrzesuniecie);
            }

            element.addEventListener('touchstart', rozpocznijPrzesuniecie);
        }

        function dodajObslugeUsuwanie(element) {
            element.addEventListener('click',
            function(){usunelgui(element)}
            );
        }
        function usunelgui(element){
          if (confirm('Czy na pewno chcesz usunąć ten element?')) {
            element.remove();
          }
        }
function ukonczoneGUI() {
  config.guiHTML=document.querySelector('gui').innerHTML
  
  
  setTimeout(function(){
    const elementyDoUsuniecia = document.querySelectorAll('.added');
    elementyDoUsuniecia.forEach(function(element) {
      element.remove();
    });
    document.querySelector('gui').innerHTML=config.guiHTML
    testa()
  },100)
}
        function usunElementy() {
            const elementyDoUsuniecia = document.querySelectorAll('.added');
            config.guiHTML2=''
            elementyDoUsuniecia.forEach(function (element) {
                element.remove();
            });
        }
    </script>
</body>
</html>
<style>
      .particle {
      position: fixed ;
      border-radius: 20%;
      opacity: 0.2;
      z-index: 99999999;
      /*filter: url("#bm")*/
      
    }
    .custom-particle {
      position: absolute;
      background-color: black ;
      border-radius: 100%;
      opacity :0.0;
      
      z-index: 999;
    }
</style>
<script>
const particleContainer = [];

    class Particle {
      constructor(x, y, lifetime, color, radius, rotationspeed, emitCount, emitLifetime, xoffset, yoffset, radiansOffset, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass,xmat) {
        this.x = x;
        this.y = y;
        this.lifetime = lifetime;
        this.xmat=xmat
        this.color = color;
        this.radius = radius;
        this.rotationspeed = rotationspeed;
        this.rotation = 0;
        this.startTime = Date.now();
        this.emitCount = emitCount;
        this.emitLifetime = emitLifetime;
        this.xoffset = xoffset;
        this.yoffset = yoffset;
        this.radiansOffset = radiansOffset;
        this.particleGoto = particleGoto;
        this.endXOffset = endXOffset;
        this.endYOffset = endYOffset;
        this.particleMovementSpeed = particleMovementSpeed;
        this.vx = Math.random() * 2 - 1; // Random velocity in the x direction between -1 and 1
        this.vy = Math.random() * 2 - 1; // Random velocity in the y direction between -1 and 1
        this.element = document.createElement('div');
        this.element.className = particleClass || 'particle'; // Use custom class if provided, otherwise use 'particle'
        this.updateStyle();
        document.querySelector('#Econtent').appendChild(this.element);
      }

      updateStyle() {
        if(this.xmat==false){
        this.element.style.left = this.x  + 'px';
        this.element.style.top = this.y  + 'px';
        }else if (this.xmat == true) {
          this.element.style.left = this.x + 'vw';
          this.element.style.top = this.y + 'vh';
        }
        this.element.style.width = this.radius * 2 + 'px';
        this.element.style.height = this.radius * 2 + 'px';
        this.element.style.background = this.color;
        this.element.style.transform = `rotate(${this.rotation}deg)`;
        this.element.style.opacity = this.lifetime / this.emitLifetime;
      }

      update() {
        const currentTime = Date.now();
        const deltaTime = (currentTime - this.startTime) / 1000;
        this.rotation += this.rotationspeed * deltaTime;

        if (deltaTime >= this.lifetime) {
          this.element.remove();
          const index = particleContainer.indexOf(this);
          particleContainer.splice(index, 1);
        }

        if (this.particleGoto) {
          this.x += this.vx * this.particleMovementSpeed; // Update particle's x position based on its velocity
          this.y += this.vy * this.particleMovementSpeed; // Update particle's y position based on its velocity
        } else {
          const angle = Math.atan2(this.endYOffset, this.endXOffset);
          this.x += Math.cos(angle) * this.particleMovementSpeed; // Move towards the specified x direction
          this.y += Math.sin(angle) * this.particleMovementSpeed; // Move towards the specified y direction
        }

        if (this.emitCount > 0 && deltaTime >= this.emitLifetime) {
          this.emitCount--;
          const radians = this.radiansOffset + (Math.random() - 0.5) * Math.PI;
          let x = this.x + this.xoffset;
          let y = this.y + this.yoffset;
          if (this.particleGoto) {
            x = this.x - this.xoffset;
            y = this.y - this.yoffset;
          }
          x += this.endXOffset;
          y += this.endYOffset;
          createParticle(x, y, this.lifetime, this.color, this.radius, this.rotationspeed, 0, this.emitLifetime, this.xoffset, this.yoffset, radians, this.particleGoto, this.endXOffset, this.endYOffset, this.particleMovementSpeed, this.particleClass);
        }
      }
    }

    function createParticle(x, y, lifetime, color, radius, rotationspeed, emitCount = 0, emitLifetime = 0, xoffset = 0, yoffset = 0, radiansOffset = 0, particleGoto = false, endXOffset = 0, endYOffset = 0, particleMovementSpeed = 1, particleClass, xmat = false ) {
      const particle = new Particle(x, y, lifetime, color, radius, rotationspeed, emitCount, emitLifetime, xoffset, yoffset, radiansOffset, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass, xmat);
      particleContainer.push(particle);
    }

    function emitParticles(x, y, particleCount, emitLifetime, color, radius, rotationspeed, xoffset, yoffset, radiansOffset, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass,xmat) {
      for (let i = 0; i < particleCount; i++) {
        const xmath=xmat 
        
        const randomX = x + (Math.random() - 0.5) * xoffset;
        const randomY = y + (Math.random() - 0.5) * yoffset;
        const randomLifetime = emitLifetime + Math.random() * 0.5;
        const randomRotSpeed = rotationspeed + (Math.random() - 0.5) * 0;
        const radians = radiansOffset + (Math.random() - 0.5) * Math.PI;
        createParticle(randomX, randomY, randomLifetime, color, radius, randomRotSpeed, 0, emitLifetime, xoffset, yoffset, radians, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass,xmath);
      }
    }

    function updateParticles() {
      for (let i = 0; i < particleContainer.length; i++) {
        const particle = particleContainer[i];
        particle.update();
        particle.updateStyle();
      }

      requestAnimationFrame(updateParticles);
    }

    function initialize() {
      // Example usage:
      

      setInterval(() => {
//emitParticles(5*tileSize2, 3*tileSize2, 1, 4.5, "rgba(255, 255, 255, 0.2)", 100, 2.5, 50, 50, 0, true, 1000, 100, 0.8, 'custom-particle',false);

emitParticles()
      }, 1000);

      // Additional example particles:
      

      updateParticles();
    }

    initialize();
  </script>



  <style>


    #editor {
      position:fixed;
      z-index: 999;
      max-width: 400px;
      height: 200px;
      width: 200px;
      top:50%;
      left:50vw;
      transform: translate(-50%,-50%);
      
      overflow: hidden;
      overflow: scroll;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    input, textarea {
      margin-bottom: 10px;
      width: calc(100% - 20px);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 14px;
    }

    .button-container {
      display: flex;
      justify-content: space-between;
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>

  <div id="editor" class="d notaproject"></div>

  <script>
    var example=config
    const editorContainer = document.getElementById('editor');


    for (const key in example) {
const namr = document.createElement('div');
namr.style.color="black"
namr.innerText=key
      editorContainer.appendChild(namr)
      if (typeof example[key] === 'number') {
        const inputContainer = document.createElement('div');
        inputContainer.className = 'button-container';

        const addButton = document.createElement('button');
        addButton.innerText = '+';
        addButton.addEventListener('touchmove', () => {
          example[key]++;
          inputElement.value = example[key];
        });
        addButton.addEventListener('click', () => {
          example[key]++;
          inputElement.value = example[key];
        });
        inputContainer.appendChild(addButton);

        const inputElement = document.createElement('input');
        inputElement.type = 'number';
        inputElement.value = example[key];
        inputElement.addEventListener('change', (event) => {
          example[key] = parseFloat(event.target.value);
        });
        inputContainer.appendChild(inputElement);

        const minusButton = document.createElement('button');
        minusButton.innerText = '-';
        minusButton.addEventListener('touchmove', () => {
          example[key]--;
          inputElement.value = example[key];
        });
        minusButton.addEventListener('click', () => {
          example[key]--;
          inputElement.value = example[key];
        });
        inputContainer.appendChild(minusButton);

        editorContainer.appendChild(inputContainer);
      } else if (Array.isArray(example[key]) || typeof example[key] === 'string') {
        const textareaElement = document.createElement('textarea');
        textareaElement.value = example[key];
        textareaElement.addEventListener('change', (event) => {
          example[key] = event.target.value;
        });
        editorContainer.appendChild(textareaElement);
      }
    }
  </script>
  



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customowy Play/Pause</title>
    <style>
        /* Styl dla customowego diva */
        #playPauseButton {
            position: fixed;
            top: 10px;
            left: 150px;
            z-index: 99999999;
            cursor: pointer;
            background-color: #3498DB;
            opacity: 0.4;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
        }

        /* Dodaj styl dla ikony play/pause */
        #playPauseIcon::before {
            content: "⏯️"; /* Unicode dla ikony trójkąta (play) */
        }

        /* Dodaj styl dla stanu pauzy */
        #playPauseButton.paused #playPauseIcon::before {
            content: "▶️"; /* Unicode dla ikony pauzy */
        }
    </style>
</head>
<body>

<!-- Dodaj customowy div -->
<div id="playPauseButton" onclick="togglePlayPause()">
    <span id="icon">⏸️</span>
</div>
<div id="playPauseButton" style="left:190px" onclick="restart()">
  <span id="icon">🔁</span>
</div>
<script>

function restart(){
  bgimg=config.bg
  const playerskin69 = config.playerskin1
//alert(playerskin69)
document.querySelector('.player').style.background = `url(${playerskin69})`
playerskin = playerskin69
updateViewport();
setTimeout(function() {
  if (config.DarknessEffect == 1) {
    let vp = document.getElementById("viewport")
    let el = document.createElement('div')
    el.style = `width:${vp.style.width};height:${vp.style.height};`
    el.className = 'dark effects added'
    document.querySelector('#project').appendChild(el)
  } else {
    let y = document.querySelectorAll('.effects')
    for (var i = 0; i < y.length; i++) {
      if (y[i].classList == 'dark') {
        y[i].remove()
      }
    }
  }
}, 1000)



deletedtiles = []
document.getElementById('edytor').textContent = config.code
stop = 1
code = config.code;
classicspeed = config.norspeed;
playerY = config.spawnY;
playerX = config.spawnX;
setPlayer(config.spawnX, config.spawnY)
speed = config.speed;
playerskin = config.playerskin1;
TILES = config.blocks;
tileMap = config.savedTileMap;
gravity = config.gravity;
content.style.backgroundSize = (config.bgsize) + "px"
code = config.code
if (audioInstance) {
  // Jeżeli istnieje istniejący odtwarzacz audio, zatrzymaj go
  audioInstance.pause();
  audioInstance.currentTime = 0;
  audioInstance = null;
}

if (config.music !== '') {
  const base64Wav = config.music;

  // Utwórz nowy odtwarzacz audio
  audioInstance = new Audio();
  audioInstance.src = base64Wav;
  audioInstance.setAttribute('preload', 'auto');

  // Dodaj odtwarzacz do dokumentu
  document.body.appendChild(audioInstance);

  // Odtwórz plik audio WAV
  audioInstance.play();
  audioInstance.loop = true;
  toonce = 0;
}

if (config.customcamera == 1) {
  viewport.scrollTo(config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight * viewportHeight / 2)
}

const contentElement = document.getElementById("content");
document.querySelector('gui').innerHTML = config.guiHTML
ukonczoneGUI()

contentElement.style.backgroundImage = `url('${config.bg}')`;
document.getElementById('Scontent').innerHTML = ''
document.getElementById('Econtent').innerHTML = ''
tileConfig = config.entities
document.getElementById('entitiesconfig').innerText = JSON.stringify(config.entities);
moveTilesRandomly()
setTimeout(function() {
  curline = 0
  currentLine = 0
  generateAllTiles()
  candocmd = 1
  curline = 0
  currentLine = 0;
  candothath = 0
  defy = 0
  jmptimes = 0
  stop = 0
  RESET()
}, 3000)
//alert(content.style.backgroundSize)
tileSize = config.tilesize; // Rozmiar pojedynczego kafelk
cfigZ = config.zoomoff;
vp = document.getElementById("viewport");
vp.style.zoom = cfigZ * config.zoomadd;

//alert((config));
}


    let agnstgui=null
    let gravity2=0
    let sidescroll2=null
    var backplayerY=0
    var backplayerX=0
    let backskin=null
    gravity2 = config.gravity
    function togglePlayPause() {
        const playPauseButton = document.getElementById('playPauseButton');

        // Zmień stan zmiennej isgamepaused
        isgamepaused = 1 - isgamepaused;
//alert(isgamepaused)
        // Dodaj lub usuń klasę "paused" w zależności od stanu isgamepaused
        playPauseButton.classList.toggle('paused', isgamepaused === 1);
        if(isgamepaused==0){
          
          }
if(isgamepaused==0){
  stop=0
  document.querySelector('.player').style.background = `url("${backskin}")`
  config.gravity = gravity2
 gravity = gravity2
  config.sidescroll = sidescroll2
  document.querySelector('gui').innerHTML = agnstgui
  playerY=backplayerY
  playerX=backplayerX
  updateViewport()
  ukonczoneGUI()

  setTimeout(function() {


    g = 1

    alert2("machine communication please stand by")
    const outputDiv = document.getElementById("codeContainer");
    outputDiv.innerHTML = ""
    document.querySelector('.vars').innerHTML = ""

    setTimeout(function() {
      g = 0
      localout = []
      Vables = {};

      nospeed2lines = false;
      candocmd = 1
      curline = 0
      currentLine = 0;
      candothath = 0
      defy = 0
      jmptimes = 0
      V = []
      interpretCode()

    }, 1000)

  }, 1500)
}else {
          
          backplayerX=playerX
          backplayerY=playerY
          backskin = config.playerskin1
          sidescroll2= config.sidescroll
          document.querySelector('.player').style.background = `url('/debug.png')`
          agnstgui=document.querySelector('gui').innerHTML
          
          
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          document.querySelector('gui').innerHTML = `  <div class="btns">
                <div class="null added"></div>
                <div class="btn added" id="Up"></div>
                <div class="null added"></div>
                <div class="btn added" id="Left"></div>
                <div class="null added"></div>
                <div class="btn added" id="Right"></div>
                <div class="null added"></div>
                <div class="btn added" id="Down"></div>
                <div class="null added"></div>
            
              </div>
          
           	   	  <div class="jumpbtn added" id="Attack" style="transform: translate(0%,-100%)" onclick="attack2()"></div>
          `
          gravity=0
          config.gravity=0
          setTimeout(function (){
            gravity=0
            config.gravity=0
          },500)
          config.sidescroll=1
          ukonczoneGUI()
          gravity=0
          stop=1
        }
    }
</script>

</body>
</html>
<style>


    
  
    @keyframes glitch-effect {
    0% { -webkit-transform: translate(0, 0); }
    5% { -webkit-transform: translate(2px, -2px); }
    10% { -webkit-transform: translate(-2px, 2px); }
    15% { -webkit-transform: translate(0, -2px); }
    20% { -webkit-transform: translate(0, 2px); }
    25% { -webkit-transform: translate(2px, 0); }
    30% { -webkit-transform: translate(-2px, -2px); }
    35% { -webkit-transform: translate(2px, 2px); }
    40% { -webkit-transform: translate(-2px, 0); }
    45% { -webkit-transform: translate(0, 0); }
    50% { -webkit-transform: translate(-2px, 2px); }
    55% { -webkit-transform: translate(2px, 2px); }
    60% { -webkit-transform: translate(-2px, 0); }
    75% { -webkit-transform: translate(0, 0); }
    80% { -webkit-transform: translate(-2px, 2px); }
    85% { -webkit-transform: translate(2px, 2px); }
    90% { -webkit-transform: translate(-2px, 0); }
    95% { -webkit-transform: translate(0, 0); }
    100% { -webkit-transform: translate(-2px, 2px); }
    
  }
</style>
<svg width="0" height="0">
  <filter id="ca">
    <feColorMatrix type="matrix" 
      result="red_"             
      values="4 0 0 0 0
              0 0 0 0 0 
              0 0 0 0 0 
              0 0 0 1 0"/>
    <feOffset in="red_" dx="0.8" dy="0" result="red"/>
    <feColorMatrix type="matrix" 
      in="SourceGraphic"             
      result="blue_"             
      values="0 0 0 0 0
              0 3 0 0 0 
              0 0 10 0 0 
              0 0 0 1 0"/>
    <feOffset in="blue_" dx="-0.8" dy="0" result="blue"/>    
    <feBlend mode="screen" in="red" in2="blue"/>

  </filter>
</svg>

<svg width="0" height="0">
  <filter id="be">
    <feGaussianBlur stdDeviation="200" result="blur"/>
    <feComposite in="SourceGraphic" in2="blur" operator="out" result="bloom"/>
    <feBlend in="SourceGraphic" in2="bloom" mode="screen"/>
  </filter>
</svg>

<script>
if(config.chrom==true){
  document.querySelector('#content').style.animation="glitch-effect 2s infinite"
  document.querySelector(':root').style.filter='url("#ca")'
}
</script>